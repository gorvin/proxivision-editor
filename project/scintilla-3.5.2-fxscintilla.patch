diff -NaurB scintilla-3.5.2/fox/PlatFOX.cxx scintilla-3.5.2-fox/fox/PlatFOX.cxx
--- scintilla-3.5.2/fox/PlatFOX.cxx	1970-01-01 01:00:00.000000000 +0100
+++ scintilla-3.5.2-fox/fox/PlatFOX.cxx	2014-12-04 12:30:18.000000000 +0100
@@ -0,0 +1,1486 @@
+/** FXScintilla source code edit control
+ *
+ *  PlatFOX.cxx - implementation of platform facilities on the FOX toolkit
+ *
+ *  Copyright 2001-2004 by Gilles Filippini <gilles.filippini@free.fr>
+ *
+ *  Adapted from the Scintilla source PlatGTK.cxx 
+ *  Copyright 1998-2004 by Neil Hodgson <neilh@scintilla.org>
+ *
+ *  ====================================================================
+ *
+ *  This file is part of FXScintilla.
+ * 
+ *  FXScintilla is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU Lesser General Public License as published by
+ *  the Free Software Foundation; either version 2.1 of the License, or
+ *  (at your option) any later version.
+ *
+ *  FXScintilla is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public License
+ *  along with FXScintilla; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ **/
+
+#include <string.h>
+#include <stdio.h>
+#include <stdlib.h>
+
+#if !defined(WIN32) || defined(__CYGWIN__)
+# if defined(__CYGWIN__)
+#  include <windows.h>
+#  ifdef PIC
+#   define FOXDLL
+#  endif
+# endif
+# include <sys/time.h>
+#  include <fx.h>
+#  include <fxkeys.h>
+#  include <FXRootWindow.h>
+#else
+# if defined(__MINGW32__) && defined(PIC) && !defined(FOXDLL)
+#   define FOXDLL
+# endif
+# pragma warning (disable : 4786)
+# include <time.h>
+# include <windows.h>
+# include <fx.h>
+# include <fxkeys.h>
+#endif  // !defined(WIN32) || defined(__CYGWIN__)
+
+#include <FX88591Codec.h>
+
+#include "Platform.h"
+#include "Scintilla.h"
+#include "ScintillaWidget.h"
+#include "FXScintilla.h"
+
+#include <map>
+using namespace std;
+
+// X has a 16 bit coordinate space, so stop drawing here to avoid wrapping
+static const int maxCoordinate = 32000;
+
+Point Point::FromLong(long lpoint) {
+  return Point(
+    Platform::LowShortFromLong(lpoint), 
+    Platform::HighShortFromLong(lpoint));
+}
+
+Font::Font() : fid(0) {}
+
+Font::~Font() {}
+
+#ifndef WIN32
+
+void Font::Create(const FontParameters &fp) {
+  Release();
+  // If name of the font begins with a '-', assume, that it is
+  // a full fontspec.
+  if (fp.faceName[0] == '-') {
+    fid = new FXFont(FXApp::instance(), fp.faceName);
+  }
+  else {
+        fid = new FXFont(FXApp::instance(), fp.faceName, fp.size,
+          fp.weight>400 ? FXFont::Bold : FXFont::Normal ,
+      fp.italic ? FXFont::Italic : FXFont::Straight,
+      fp.characterSet);
+  }
+  if (!fid) {
+    // Font not available so substitute with the app default font.
+    fid = FXApp::instance()->getNormalFont();
+  }
+  if (fid)
+    fid->create();
+}
+
+#else // WIN32
+
+static int CharacterSetCode(int characterSet) {
+  switch (characterSet) {
+  case SC_CHARSET_ANSI:
+    return FONTENCODING_DEFAULT;
+  case SC_CHARSET_DEFAULT:
+    return FONTENCODING_DEFAULT;
+  case SC_CHARSET_BALTIC:
+    return FONTENCODING_BALTIC;
+  case SC_CHARSET_CHINESEBIG5:
+    return FONTENCODING_DEFAULT;
+  case SC_CHARSET_EASTEUROPE:
+    return FONTENCODING_EASTEUROPE;
+  case SC_CHARSET_GB2312:
+    return FONTENCODING_DEFAULT;
+  case SC_CHARSET_GREEK:
+    return FONTENCODING_GREEK;
+  case SC_CHARSET_HANGUL:
+    return FONTENCODING_DEFAULT;
+  case SC_CHARSET_MAC:
+    return FONTENCODING_DEFAULT;
+  case SC_CHARSET_OEM:
+    return FONTENCODING_DEFAULT;
+  case SC_CHARSET_RUSSIAN:
+    return FONTENCODING_RUSSIAN;
+  case SC_CHARSET_CYRILLIC:
+    return FONTENCODING_CYRILLIC;
+  case SC_CHARSET_SHIFTJIS:
+    return FONTENCODING_DEFAULT;
+  case SC_CHARSET_SYMBOL:
+    return FONTENCODING_DEFAULT;
+  case SC_CHARSET_TURKISH:
+    return FONTENCODING_TURKISH;
+  case SC_CHARSET_JOHAB:
+    return FONTENCODING_DEFAULT;
+  case SC_CHARSET_HEBREW:
+    return FONTENCODING_HEBREW;
+  case SC_CHARSET_ARABIC:
+    return FONTENCODING_ARABIC;
+  case SC_CHARSET_VIETNAMESE:
+    return FONTENCODING_CP1258;     /// Windows Vietnam
+  case SC_CHARSET_THAI:
+    return FONTENCODING_THAI;
+  case SC_CHARSET_8859_15:
+    return FONTENCODING_ISO_8859_15;
+  default:
+    return FONTENCODING_DEFAULT;
+  }
+}
+
+void Font::Create(const FontParameters &fp) {
+  Release();
+  fid = new FXFont(FXApp::instance(), fp.faceName, fp.size,
+          fp.weight>400 ? FXFont::Bold : FXFont::Normal ,
+      fp.italic ? FXFont::Italic : FXFont::Straight,
+      CharacterSetCode(fp.characterSet));
+  if (!fid) {
+    // Font not available so substitute with the app default font.
+    fid = FXApp::instance()->getNormalFont();
+  }
+  if (fid)
+    fid->create();
+}
+
+#endif // WIN32
+
+void Font::Release() {
+  if (fid)
+    delete fid;
+  fid = 0;
+}
+
+// ====================================================================
+// Surface
+// ====================================================================
+
+class SurfaceImpl : public Surface {
+  bool unicodeMode;
+  FXDrawable *drawable;
+  FXImage *ppixmap;
+  static SurfaceImpl *s_dc_owner;
+  FXDCWindow *_dc;
+  FXDCWindow *dc();
+  int x;
+  int y;
+  bool inited;
+  bool createdDC;
+  FX88591Codec asciiCodec;
+  FXString codecBuffer;
+public:
+  SurfaceImpl();
+  virtual ~SurfaceImpl();
+
+  void Init(WindowID wid);
+  void Init(SurfaceID sid, WindowID wid);
+  void InitPixMap(int width, int height, Surface *surface_, WindowID wid);
+
+  void Release();
+  bool Initialised();
+  void PenColour(ColourDesired fore);
+  void BackColour(ColourDesired back);
+  int LogPixelsY();
+  int DeviceHeightFont(int points);
+  void MoveTo(int x_, int y_);
+  void LineTo(int x_, int y_);
+  void Polygon(Point *pts, int npts, ColourDesired fore, ColourDesired back);
+  void RectangleDraw(PRectangle rc, ColourDesired fore, ColourDesired back);
+  void FillRectangle(PRectangle rc, ColourDesired back);
+  void FillRectangle(PRectangle rc, Surface &surfacePattern);
+  void RoundedRectangle(PRectangle rc, ColourDesired fore, ColourDesired back);
+  void AlphaRectangle(PRectangle rc, int cornerSize, ColourDesired fill, int alphaFill,
+    ColourDesired outline, int alphaOutline, int flags);
+  void Ellipse(PRectangle rc, ColourDesired fore, ColourDesired back);
+  void Copy(PRectangle rc, Point from, Surface &surfaceSource);
+
+  void DrawTextBase(PRectangle rc, Font &font_, int ybase, const char *s, int len, ColourDesired fore);
+  void DrawTextNoClip(PRectangle rc, Font &font_, XYPOSITION ybase, const char *s, int len, ColourDesired fore, ColourDesired back);
+  void DrawTextClipped(PRectangle rc, Font &font_, XYPOSITION ybase, const char *s, int len, ColourDesired fore, ColourDesired back);
+  void DrawTextTransparent(PRectangle rc, Font &font_, XYPOSITION ybase, const char *s, int len, ColourDesired fore);
+  void MeasureWidths(Font &font_, const char *s, int len, XYPOSITION *positions);
+  XYPOSITION WidthText(Font &font_, const char *s, int len);
+  XYPOSITION WidthChar(Font &font_, char ch);
+  XYPOSITION Ascent(Font &font_);
+  XYPOSITION Descent(Font &font_);
+  XYPOSITION InternalLeading(Font &font_);
+  XYPOSITION ExternalLeading(Font &font_);
+  XYPOSITION Height(Font &font_);
+  XYPOSITION AverageCharWidth(Font &font_);
+
+  void SetClip(PRectangle rc);
+  void FlushCachedState();
+
+  void SetUnicodeMode(bool unicodeMode_);
+  virtual void SetDBCSMode(int /* codePage */) {}
+  virtual void DrawRGBAImage(PRectangle rc, int width, int height, const unsigned char *pixelsImage);
+};
+
+SurfaceImpl * SurfaceImpl::s_dc_owner = NULL;
+
+SurfaceImpl::SurfaceImpl() : unicodeMode(false), drawable(0), ppixmap(0), _dc(0),
+x(0), y(0), inited(false) {}
+
+
+SurfaceImpl::~SurfaceImpl() {
+  Release();
+}
+
+FXDCWindow * SurfaceImpl::dc()
+{
+  if (s_dc_owner != this) {
+    if (s_dc_owner) {
+      delete s_dc_owner->_dc;
+      s_dc_owner->_dc = NULL;
+    }
+    s_dc_owner = this;
+    _dc = (drawable) ? new FXDCWindow(drawable) : NULL;
+    // Ask for lines that do not paint the last pixel so is like Win32
+    if (_dc)
+      _dc->setLineCap(CAP_NOT_LAST);
+  }
+  return _dc;
+    
+}
+
+void SurfaceImpl::Release() {
+  drawable = 0;
+  if (_dc) {
+    delete _dc;
+    _dc = 0;
+    s_dc_owner = 0;
+  }
+  if (ppixmap)
+    delete ppixmap;
+  ppixmap = 0;
+  x = 0;
+  y = 0;
+  createdDC = false;
+  inited = false;
+}
+
+bool SurfaceImpl::Initialised() {
+  return inited;
+}
+
+void SurfaceImpl::Init(WindowID) {
+  Release();
+  inited = true;
+}
+
+void SurfaceImpl::Init(SurfaceID sid, WindowID) {
+  Release();
+  drawable = reinterpret_cast<FXDrawable *>(sid);
+  createdDC = true;
+  inited = true;
+}
+
+void SurfaceImpl::InitPixMap(int width, int height, Surface*, WindowID) {
+  Release();
+  if (height > 0 && width > 0)
+    ppixmap = new FXImage(FXApp::instance(), NULL, 0, width, height);
+  else
+    ppixmap = NULL;
+  drawable = ppixmap;
+  if (drawable)
+    drawable->create();
+  createdDC = true;
+  inited = true;
+}
+
+#if defined(FOX_1_7) && ((FOX_MAJOR>1)||(FOX_MINOR>7)||(FOX_LEVEL>25))
+# define SCI_TO_FOX_COLOR(cd) FXRGB(cd.GetBlue(), cd.GetGreen(), cd.GetRed())
+#else
+# define SCI_TO_FOX_COLOR(cd) FXRGB(cd.GetRed(), cd.GetGreen(), cd.GetBlue())
+#endif
+
+void SurfaceImpl::PenColour(ColourDesired fore) {
+  if (dc()) {
+    ColourDesired cd(fore.AsLong());
+    _dc->setForeground(SCI_TO_FOX_COLOR(cd));
+  }
+}
+
+void SurfaceImpl::BackColour(ColourDesired back) {
+  if (dc()) {
+    ColourDesired cd(back.AsLong());
+    _dc->setBackground(SCI_TO_FOX_COLOR(cd));
+  }
+}
+
+int SurfaceImpl::LogPixelsY() {
+  return 72;
+}
+
+int SurfaceImpl::DeviceHeightFont(int points) {
+  int logPix = LogPixelsY();
+  return (points * logPix + logPix / 2) / 72;
+}
+
+void SurfaceImpl::MoveTo(int x_, int y_) {
+  x = x_;
+  y = y_;
+}
+
+void SurfaceImpl::LineTo(int x_, int y_) {
+  if (dc()) {
+    _dc->drawLine(x, y, x_, y_);
+  }
+  x = x_;
+  y = y_;
+}
+
+void SurfaceImpl::Polygon(Point *pts, int npts, ColourDesired fore,
+                      ColourDesired back) {
+  if (dc()) {
+    FXPoint gpts[20];
+    if (npts < static_cast<int>((sizeof(gpts)/sizeof(gpts[0])))) {
+      for (int i=0;i<npts;i++) {
+        gpts[i].x = pts[i].x;
+        gpts[i].y = pts[i].y;
+      }
+      gpts[npts].x = pts[0].x;
+      gpts[npts].y = pts[0].y;
+      PenColour(back);
+      _dc->fillPolygon(gpts, npts);
+      PenColour(fore);
+      _dc->drawLines(gpts, npts + 1);
+    }
+  }
+}
+
+void SurfaceImpl::RectangleDraw(PRectangle rc, ColourDesired fore, ColourDesired back) {
+  if (dc()) {
+    PenColour(fore);
+    BackColour(back);
+    _dc->drawRectangle(rc.left, rc.top,
+                      rc.right - rc.left + 1, rc.bottom - rc.top + 1);
+  }
+}
+
+void SurfaceImpl::FillRectangle(PRectangle rc, ColourDesired back) {
+  if (dc() && (rc.left < maxCoordinate)) {  // Protect against out of range
+    // GTK+ rectangles include their lower and right edges
+    rc.bottom--;
+    rc.right--;
+    PenColour(back);
+    _dc->fillRectangle(rc.left, rc.top,
+            rc.right - rc.left + 1, rc.bottom - rc.top + 1);
+  }
+}
+
+void SurfaceImpl::FillRectangle(PRectangle rc, Surface &surfacePattern) {
+  if (static_cast<SurfaceImpl &>(surfacePattern).drawable) {
+    if (dc()) {
+      // Tile pattern over rectangle
+      // Currently assumes 8x8 pattern
+      int widthPat = 8;
+      int heightPat = 8;
+      for (int xTile = rc.left; xTile < rc.right; xTile += widthPat) {
+        int widthx = (xTile + widthPat > rc.right) ? rc.right - xTile : widthPat;
+        for (int yTile = rc.top; yTile < rc.bottom; yTile += heightPat) {
+          int heighty = (yTile + heightPat > rc.bottom) ? rc.bottom - yTile : heightPat;
+          _dc->drawArea(static_cast<SurfaceImpl &>(surfacePattern).drawable,
+                        0, 0,
+                        widthx, heighty,
+                        xTile, yTile);
+        }
+      }
+    }
+  } else {
+    // Something is wrong so try to show anyway
+    // Shows up black because colour not allocated
+    FillRectangle(rc, ColourDesired(0));
+  }
+}
+
+void SurfaceImpl::RoundedRectangle(PRectangle rc, ColourDesired fore, ColourDesired back) {
+  if (((rc.right - rc.left) > 4) && ((rc.bottom - rc.top) > 4)) {
+    // Approximate a round rect with some cut off corners
+    Point pts[] = {
+        Point(rc.left + 2, rc.top),
+        Point(rc.right - 2, rc.top),
+        Point(rc.right, rc.top + 2),
+        Point(rc.right, rc.bottom - 2),
+        Point(rc.right - 2, rc.bottom),
+        Point(rc.left + 2, rc.bottom),
+        Point(rc.left, rc.bottom - 2),
+        Point(rc.left, rc.top + 2),
+    };
+    Polygon(pts, sizeof(pts) / sizeof(pts[0]), fore, back); 
+  } else {
+    RectangleDraw(rc, fore, back);
+  }
+}
+
+// Plot a point into a guint32 buffer symetrically to all 4 qudrants
+static void AllFour(FXImage *image, int width, int height, int x, int y, FXColor color) {
+  image->setPixel(x, y, color);
+  image->setPixel(width-1-x, y, color);
+  image->setPixel(x, height-1-y, color);
+  image->setPixel(width-1-x, height-1-y, color);
+}
+
+static unsigned int GetRed(unsigned int co) {
+  return (co >> 16) & 0xff;
+}
+
+static unsigned int GetGreen(unsigned int co) {
+  return (co >> 8) & 0xff;
+}
+
+static unsigned int GetBlue(unsigned int co) {
+  return co & 0xff;
+}
+
+void SurfaceImpl::AlphaRectangle(PRectangle rc, int cornerSize, ColourDesired fill, int alphaFill,
+    ColourDesired outline, int alphaOutline, int flags) {
+  (void)flags;
+  if (dc()) {
+    int width = rc.Width();
+    int height = rc.Height();
+    // Ensure not distorted too much by corners when small
+    cornerSize = Platform::Minimum(cornerSize, (Platform::Minimum(width, height) / 2) - 2);
+    // Make a 32 bit deep image
+    FXImage * image = new FXImage(FXApp::instance(), NULL, IMAGE_OWNED, width, height);
+
+    FXColor valEmpty = 0;
+    FXColor valFill = FXRGBA(GetRed(fill.AsLong()), GetGreen(fill.AsLong()), GetBlue(fill.AsLong()), alphaFill);
+    FXColor valOutline = FXRGBA(GetRed(outline.AsLong()), GetGreen(outline.AsLong()), GetBlue(outline.AsLong()), alphaOutline);
+    for (int pY=0; pY<height; pY++) {
+      for (int pX=0; pX<width; pX++) {
+        if ((pX==0) || (pX==width-1) || (pY == 0) || (pY == height-1)) {
+          image->setPixel(pX, pY, valOutline);
+        } else {
+          image->setPixel(pX, pY, valFill);
+        }
+      }
+    }
+    for (int c=0;c<cornerSize; c++) {
+      for (int pX=0;pX<c+1; pX++) {
+        AllFour(image, width, height, pX, c-pX, valEmpty);
+      }
+    }
+    for (int pX=1;pX<cornerSize; pX++) {
+      AllFour(image, width, height, pX, cornerSize-pX, valOutline);
+    }
+
+    // Draw with alpha
+    image->create();
+    _dc->drawImage(image, rc.left, rc.top);
+  }
+}
+
+
+void SurfaceImpl::Ellipse(PRectangle rc, ColourDesired fore, ColourDesired back) {
+  if (dc()) {
+    PenColour(back);
+    _dc->fillArc(rc.left, rc.top,
+          rc.right - rc.left, rc.bottom - rc.top,
+          0, 32767);
+    PenColour(fore);
+    _dc->drawArc(rc.left, rc.top,
+          rc.right - rc.left, rc.bottom - rc.top,
+          0, 32767);
+  }
+}
+
+void SurfaceImpl::Copy(PRectangle rc, Point from, Surface &surfaceSource) {
+  if (dc() && static_cast<SurfaceImpl &>(surfaceSource).drawable) {
+    _dc->drawArea(static_cast<SurfaceImpl &>(surfaceSource).drawable,
+                 from.x, from.y,
+                 rc.right - rc.left, rc.bottom - rc.top ,
+                 rc.left, rc.top);
+  }
+}
+
+void SurfaceImpl::DrawTextBase(PRectangle rc, Font &font_, int ybase, const char *s, int len, ColourDesired fore)
+{
+  if (dc()) {
+    PenColour(fore);
+    _dc->setFont(font_.GetID());
+    const int segmentLength = 1000;
+    int xbase = rc.left;
+    if (codecBuffer.length()) { codecBuffer=FXString::null; }
+    if (!unicodeMode) { // Fox uses UTF8 for text drawing, so we must convert any extended ASCII first.
+      for (int p=0; p<len; p++) {
+        if ((FXuchar)(s[p])>126) {
+          codecBuffer.length(asciiCodec.mb2utflen(s,len));
+          asciiCodec.mb2utf(&(codecBuffer.at(0)),codecBuffer.length(),s,len);
+          len=codecBuffer.length();
+          break;
+        }
+      }
+    }
+    while ((len > 0) && (xbase < maxCoordinate)) {
+      int lenDraw = Platform::Minimum(len, segmentLength);
+      _dc->drawText(xbase, ybase, codecBuffer.length()?codecBuffer.text():s, lenDraw);
+      len -= lenDraw;
+      if (len > 0) {
+        xbase += font_.GetID()->getTextWidth(s, lenDraw);
+      }
+      s += lenDraw;
+    }
+  }
+  if (codecBuffer.length()) { codecBuffer=FXString::null; }
+}
+
+void SurfaceImpl::DrawTextNoClip(PRectangle rc, Font &font_, XYPOSITION ybase, const char *s, int len,
+                       ColourDesired fore, ColourDesired back) {
+  if (dc()) {
+    FillRectangle(rc, back);
+    DrawTextBase(rc, font_, ybase, s, len, fore);
+  }
+}
+
+// On GTK+, exactly same as DrawText NoClip
+// <FIXME> what about FOX ? </FIXME>
+void SurfaceImpl::DrawTextClipped(PRectangle rc, Font &font_, XYPOSITION ybase, const char *s, int len,
+                       ColourDesired fore, ColourDesired back) {
+  DrawTextNoClip(rc, font_, ybase, s, len, fore, back);
+}
+
+void SurfaceImpl::DrawTextTransparent(PRectangle rc, Font &font_, XYPOSITION ybase, const char *s, int len,
+                                      ColourDesired fore) {
+  DrawTextBase(rc, font_, ybase, s, len, fore);
+}
+
+void SurfaceImpl::MeasureWidths(Font &font_, const char *s, int len, XYPOSITION *positions) {
+  if (font_.GetID()) {
+    int totalWidth = 0;
+    if (unicodeMode) {
+      const char*p=s;
+      for (FXint i=0; i<len; i++) {
+        int cw=1; // number of bytes in this utf8 character
+        FXuchar c=*p;
+        if (c>127) { // no check for invalid bytes here, there's not much we could do about it anyway.
+          if ((c>=194) && (c<=223)) {
+            cw=2;
+          } else if (c<=239) {
+            cw=3;        
+          } else if (c<=244) {
+            cw=4;
+          }
+        }
+        int width = font_.GetID()->getTextWidth(p, cw);
+        totalWidth += width;
+        positions[i] = totalWidth;
+        p+=cw; // this many bytes consumed
+        for (FXint j=1; j<cw; j++) { // assign the same position to each byte for multibyte chars
+          positions[i+1]=positions[i];
+          i++;
+        }
+      }
+    } else {
+      for (int i=0;i<len;i++) {
+        int default_width=font_.GetID()->getTextWidth("8", 1);
+#ifdef WIN32 // The width of chars > #239 are incorrect on Win32, so use default.
+        int width = ((FXuchar)(s[i])<=239) ? font_.GetID()->getTextWidth(s + i, 1) : default_width;
+#else
+        int width = font_.GetID()->getTextWidth(s + i, 1);
+#endif
+        totalWidth += width?width:default_width;
+        positions[i] = totalWidth;
+      }
+    }  
+  } else {
+    for (int i=0;i<len;i++) {
+      positions[i] = i + 1;
+    }
+  }
+}
+
+XYPOSITION SurfaceImpl::WidthText(Font &font_, const char *s, int len) {
+  if (font_.GetID())
+    return font_.GetID()->getTextWidth(s, len);
+  else
+    return 1;
+}
+
+XYPOSITION SurfaceImpl::WidthChar(Font &font_, char ch) {
+  if (font_.GetID())
+    return font_.GetID()->getTextWidth(&ch, 1);
+  else
+    return 1;
+}
+
+XYPOSITION SurfaceImpl::Ascent(Font &font_) {
+  if (!font_.GetID())
+    return 1;
+  return font_.GetID()->getFontAscent();
+}
+
+XYPOSITION SurfaceImpl::Descent(Font &font_) {
+  if (!font_.GetID())
+    return 1;
+  return font_.GetID()->getFontDescent();
+}
+
+XYPOSITION SurfaceImpl::InternalLeading(Font &) {
+  return 0;
+}
+
+XYPOSITION SurfaceImpl::ExternalLeading(Font &) {
+  return 0;
+}
+
+XYPOSITION SurfaceImpl::Height(Font &font_) {
+  if (!font_.GetID())
+    return 1;
+  return font_.GetID()->getFontHeight();
+}
+
+XYPOSITION SurfaceImpl::AverageCharWidth(Font &font_) {
+  if (font_.GetID())
+    return font_.GetID()->getTextWidth("n", 1);
+  else
+    return 1;
+}
+
+void SurfaceImpl::SetClip(PRectangle rc) {
+  if (dc())
+    _dc->setClipRectangle(rc.left, rc.top,
+                       rc.right - rc.left, rc.bottom - rc.top);
+}
+
+void SurfaceImpl::FlushCachedState() {}
+
+void SurfaceImpl::SetUnicodeMode(bool unicodeMode_) {
+  unicodeMode=unicodeMode_;
+}
+
+Surface *Surface::Allocate(int technology) {
+  (void)technology;
+  return new SurfaceImpl;
+}
+
+void SurfaceImpl::DrawRGBAImage( PRectangle rc, int width, int height, 
+                               const unsigned char *pixelsImage) {
+  (void)rc;
+  (void)width;
+  (void)height;
+  (void)pixelsImage;
+}
+
+Window::~Window() {}
+
+void Window::Destroy() {
+  if (wid)
+    delete wid;
+  wid = 0;
+}
+
+bool Window::HasFocus() {
+  return wid->hasFocus();
+}
+
+PRectangle Window::GetPosition() {
+  // Before any size allocated pretend its 1000 wide so not scrolled
+  PRectangle rc(0, 0, 1000, 1000);
+  if (wid) {
+    rc.left = wid->getX();
+    rc.top = wid->getY();
+    rc.right = rc.left + wid->getWidth();
+    rc.bottom = rc.top + wid->getHeight();
+  }
+  return rc;
+}
+
+void Window::SetPosition(PRectangle rc) {
+  wid->position(rc.left, rc.top, rc.Width(), rc.Height());
+}
+
+
+void Window::SetPositionRelative(PRectangle rc, Window relativeTo) {
+  int ox = relativeTo.GetID()->getX() + rc.left;
+  int oy = relativeTo.GetID()->getY() + rc.top;
+  if (ox < 0)
+    ox = 0;
+  if (oy < 0)
+    oy = 0;
+
+  /* do some corrections to fit into screen */
+  int sizex = rc.right - rc.left;
+  int sizey = rc.bottom - rc.top;
+  int screenWidth = FXApp::instance()->getRootWindow()->getDefaultWidth();
+  int screenHeight = FXApp::instance()->getRootWindow()->getDefaultHeight();
+  if (sizex > screenWidth)
+    ox = 0; /* the best we can do */
+  else if (ox + sizex > screenWidth)
+    ox = screenWidth - sizex;
+  if (oy + sizey > screenHeight)
+    oy = screenHeight - sizey;
+
+  wid->position(ox, oy, rc.Width(), rc.Height());
+}
+
+PRectangle Window::GetClientPosition() {
+  // On GTK+, the client position is the window position
+  return PRectangle(0, 0, (wid) ? wid->getWidth() - 1 : 1000, (wid) ? wid->getHeight() -1 : 1000);
+}
+
+void Window::Show(bool show) {
+  if (show) {
+    wid->show();
+    wid->raise();
+  }
+  else
+    wid->hide();
+}
+
+void Window::InvalidateAll() {
+  if (wid) {
+    wid->update();
+  }
+}
+
+void Window::InvalidateRectangle(PRectangle rc) {
+  if (wid)
+    wid->update(rc.left, rc.top, rc.right - rc.left + 1, rc.bottom - rc.top + 1);
+}
+
+void Window::SetFont(Font &) {
+  // TODO
+}
+
+void Window::SetCursor(Cursor curs) {
+  // We don't set the cursor to same value numerous times under FOX because
+  // it stores the cursor in the window once it's set
+  if (curs == cursorLast)
+    return;
+  FXDefaultCursor cursorID;
+  cursorLast = curs;
+
+  switch (curs) {
+  case cursorText:
+    cursorID = DEF_TEXT_CURSOR;
+    break;
+  case cursorArrow:
+    cursorID = DEF_ARROW_CURSOR;
+    break;
+  case cursorUp:
+    cursorID = DEF_MOVE_CURSOR;
+    break;
+  case cursorWait:
+    cursorID = DEF_SWATCH_CURSOR;
+    break;
+  case cursorHand:
+    // <FIXME/> Should be a hand cursor...
+        cursorID = DEF_HAND_CURSOR; //JKP
+//    cursorID = DEF_CROSSHAIR_CURSOR;
+    break;
+  case cursorReverseArrow:
+    cursorID = DEF_RARROW_CURSOR;
+    break;
+  default:
+    cursorID = DEF_ARROW_CURSOR;
+    cursorLast = cursorArrow;
+    break;
+  }
+  wid->setDefaultCursor(wid->getApp()->getDefaultCursor(cursorID));
+}
+
+void Window::SetTitle(const char *s) {
+  static_cast<FXTopWindow *>(wid)->setTitle(s);
+}
+
+
+/*** JKP: FIXME: Ugly and not tested !!! ***/
+PRectangle Window::GetMonitorRect(Point pt) {
+  (void)pt;
+  FXRootWindow *rootwin=wid->getApp()->getRootWindow(); //(id->getApp(),id->getVisual());
+  FXint xpos=wid->getX();
+  FXint ypos=wid->getY();
+  return PRectangle(-xpos, -ypos, (-xpos) + rootwin->getDefaultWidth(),
+                    (-ypos) + rootwin->getDefaultHeight());
+}
+
+// ====================================================================
+// ListBoxFox
+// ====================================================================
+
+class ListBoxFox : public ListBox
+{
+  Window * Parent;
+  FXList * list;
+  map<int, FXXPMIcon *> * pixhash;
+  int desiredVisibleRows;
+  unsigned int maxItemCharacters;
+  unsigned int aveCharWidth;
+public:
+  CallBackAction doubleClickAction;
+  void *doubleClickActionData;
+
+  ListBoxFox() : list(0), pixhash(NULL), desiredVisibleRows(5), maxItemCharacters(0),
+    doubleClickAction(NULL), doubleClickActionData(NULL) {
+  }
+  virtual ~ListBoxFox() {
+    ClearRegisteredImages();
+  }
+  virtual void Show(bool show=true);
+  virtual void SetFont(Font &font);
+  virtual void Create(Window &parent, int ctrlID, Point location, int lineHeight_, bool unicodeMode_, int technology_);
+  virtual void SetAverageCharWidth(int width);
+  virtual void SetVisibleRows(int rows);
+  virtual int GetVisibleRows() const;
+  virtual PRectangle GetDesiredRect();
+  virtual int CaretFromEdge();
+  virtual void Clear();
+  virtual void Append(char *s, int type = -1);
+  virtual int Length();
+  virtual void Select(int n);
+  virtual int GetSelection();
+  virtual int Find(const char *prefix);
+  virtual void GetValue(int n, char *value, int len);
+  virtual void RegisterImage(int type, const char *xpm_data);
+  virtual void ClearRegisteredImages();
+  virtual void SetDoubleClickAction(CallBackAction action, void *data) {
+    doubleClickAction = action;
+    doubleClickActionData = data;
+  }
+  virtual void SetList(const char* list, char separator, char typesep);
+  virtual void RegisterRGBAImage(int type, int width, int height, const unsigned char *pixelsImage);
+  Window* GetParent() { return Parent; }
+};
+
+
+static int sListSortFunction(const FXListItem* item1, const FXListItem* item2) {
+  return compare(item1->getText(), item2->getText());
+}
+
+class ListBoxList: public FXList {
+private:
+  FXDECLARE(ListBoxList)
+  ListBoxList(){}
+  ListBoxFox*listBox;
+public: 
+  ListBoxList(FXComposite*p, ListBoxFox*lbf):FXList(p, NULL, 0, LIST_BROWSESELECT|LAYOUT_FILL_X|LAYOUT_FILL_Y|SCROLLERS_TRACK|HSCROLLER_NEVER) {
+    listBox=lbf;
+    setSortFunc(sListSortFunction);
+  }
+  long onKeyPress(FXObject*o, FXSelector sel, void*p) {
+    FXEvent*event = (FXEvent*)p;
+    switch(event->code) {
+
+      case KEY_Up:
+      case KEY_KP_Up:
+      case KEY_Down:
+      case KEY_KP_Down:
+      case KEY_Home:
+      case KEY_KP_Home:
+      case KEY_End:
+      case KEY_KP_End: {
+        return FXList::onKeyPress(o,sel,p);
+      }
+      case KEY_Page_Up:
+      case KEY_KP_Page_Up: {
+        setCurrentItem(current>visible?current-visible:0);
+        return FXList::onKeyPress(o,sel,p);
+      }
+      case KEY_Page_Down:
+      case KEY_KP_Page_Down: {
+        setCurrentItem((current+visible)>(items.no()-1)?items.no()-1:current+visible);
+        return FXList::onKeyPress(o,sel,p);
+      }
+      default: {
+        return 0;
+      }
+    }
+  }
+  long onDoubleClicked(FXObject *o, FXSelector sel, void*p) {
+    FXList::onDoubleClicked(o,sel,p);
+    if (listBox->doubleClickAction) {
+      listBox->doubleClickAction(listBox->doubleClickActionData);
+      return 1;
+    } else {
+      FXEvent ev;
+      ev.type=SEL_KEYPRESS;
+      ev.code=KEY_Tab;
+      return listBox->GetParent()->GetID()->handle(o,MKUINT(0, SEL_KEYPRESS),&ev);
+    }
+  }
+};
+
+FXDEFMAP(ListBoxList) ListBoxListMap[] = {
+  FXMAPFUNC(SEL_KEYPRESS,0,ListBoxList::onKeyPress),
+  FXMAPFUNC(SEL_DOUBLECLICKED,0,ListBoxList::onDoubleClicked),
+};
+FXIMPLEMENT(ListBoxList,FXList,ListBoxListMap,ARRAYNUMBER(ListBoxListMap))
+
+
+
+// ====================================================================
+
+void ListBoxFox::Create(Window &parent, int ctrlID, Point location, int lineHeight_, bool unicodeMode_, int technology_) {
+  (void)ctrlID;
+  (void)location;
+  (void)lineHeight_;
+  (void)unicodeMode_;
+  (void)technology_;
+  Parent=&parent;
+  wid = new FXPacker(static_cast<FXComposite*>(parent.GetID()), FRAME_NONE|LAYOUT_EXPLICIT,0,0,0,0,1,1,1,1,0,0);
+  list = new ListBoxList(static_cast<FXComposite*>(wid),this);
+  wid->setBackColor(list->getTextColor());
+  wid->create();
+}
+
+void ListBoxFox::SetFont(Font &scint_font) {
+  list->setFont(scint_font.GetID());
+}
+
+void ListBoxFox::SetAverageCharWidth(int width) {
+    aveCharWidth = width;
+}
+
+void ListBoxFox::SetVisibleRows(int rows) {
+  list->setNumVisible(rows);
+}
+
+int ListBoxFox::GetVisibleRows() const {
+  return list->getNumVisible();
+}
+
+PRectangle ListBoxFox::GetDesiredRect() {
+  // Before any size allocated pretend its 100 wide so not scrolled
+  PRectangle rc(0, 0, 100, 100);
+  if (wid) {
+    // Height
+    int rows = Length();
+    if ((rows == 0) || (rows > desiredVisibleRows))
+      rows = desiredVisibleRows;
+    list->setNumVisible(rows);
+    rc.bottom = wid->getHeight();
+    // Width
+    int width = maxItemCharacters;
+    if (width < 12)
+      width = 12;
+    rc.right = width * (aveCharWidth+aveCharWidth/3);
+    if (Length() > rows)
+      rc.right += list->verticalScrollBar()->getWidth();
+
+    // <FIXME/>
+/*    int rows = Length();
+    if ((rows == 0) || (rows > desiredVisibleRows))
+      rows = desiredVisibleRows;
+    
+    GtkRequisition req;
+    int height;
+
+    // First calculate height of the clist for our desired visible row count otherwise it tries to expand to the total # of rows
+    height = (rows * GTK_CLIST(list)->row_height
+              + rows + 1
+              + 2 * (list->style->klass->ythickness 
+                     + GTK_CONTAINER(list)->border_width));
+    gtk_widget_set_usize(GTK_WIDGET(list), -1, height);
+
+    // Get the size of the scroller because we set usize on the window
+    gtk_widget_size_request(GTK_WIDGET(scroller), &req);
+    rc.right = req.width;
+    rc.bottom = req.height;
+                
+    gtk_widget_set_usize(GTK_WIDGET(list), -1, -1);
+    int width = maxItemCharacters;
+    if (width < 12)
+      width = 12;
+    rc.right = width * (aveCharWidth+aveCharWidth/3);
+    if (Length() > rows)
+      rc.right = rc.right + 16;*/
+  }
+  return rc;
+    
+}
+
+void ListBoxFox::Show(bool show) {
+  if (show) {
+    list->selectItem(0);
+    list->setCurrentItem(0);
+    list->setFocus();
+    FXPacker *shell=static_cast<FXPacker*>(wid);
+    FXScintilla*sci=static_cast<FXScintilla*>(Parent->GetID());
+    FXint x=shell->getX();
+    FXint y=shell->getY();
+    FXint w=list->getWidth();
+    FXint h=shell->getDefaultHeight();
+    FXint sci_w = sci->getWidth();
+    FXint sci_h = sci->getHeight();
+    sci_w -= sci->isVerticalScrollable()?sci->verticalScrollBar()->getWidth():0;
+    sci_h -= sci->isHorizontalScrollable()?sci->horizontalScrollBar()->getHeight():0;
+    x -= sci->getX();
+    y -= sci->getY();
+    if ( x+w > sci_w ) {
+      x=sci_w-w;
+    }
+    if ( y+h > sci_h ) {
+      FXint line_hgt=sci->sendMessage(SCI_TEXTHEIGHT,sci->sendMessage(SCI_LINEFROMPOSITION,sci->sendMessage(SCI_GETCURRENTPOS,0,0),0),0);
+      y=y-(h+line_hgt);
+    }
+    shell->position(x,y,w,h);
+    shell->show();
+  }
+}
+
+int ListBoxFox::CaretFromEdge() {
+  // <FIXME/> return 4 + GetWidth();
+  return 0;
+}
+
+void ListBoxFox::Clear() {
+  list->clearItems();
+  maxItemCharacters = 0;
+}
+
+void ListBoxFox::Append(char *s, int type) {
+  FXXPMIcon * icon = NULL;
+  if ((type >= 0) && pixhash) {
+    map<int, FXXPMIcon *>::iterator it = pixhash->find(type);
+    if (it != pixhash->end())
+      icon = (*it).second;
+  }
+  list->appendItem(s, icon);
+  size_t len = strlen(s);
+  if (maxItemCharacters < len)
+          maxItemCharacters = len;
+  if (list->getNumItems() <= desiredVisibleRows)
+    list->setNumVisible(list->getNumItems());
+}
+
+int ListBoxFox::Length() {
+  if (wid)
+    return list->getNumItems();
+  return 0;
+}
+
+void ListBoxFox::Select(int n) {
+  // Case n==-1 handled by FXList
+  list->setCurrentItem(n, true);
+  list->selectItem(n);
+  list->makeItemVisible(n);
+}
+
+int ListBoxFox::GetSelection() {
+  // Returns -1 when no current item
+  return list->getCurrentItem();
+}
+
+int ListBoxFox::Find(const char *prefix) {
+  int count = Length();
+  for (int i = 0; i < count; i++) {
+    FXString text = list->getItemText(i);
+    const char* s = text.text();
+    if (s && (0 == strncmp(prefix, s, strlen(prefix)))) {
+      return i;
+    }
+  }
+  return - 1;
+}
+
+void ListBoxFox::GetValue(int n, char *value, int len) {
+  FXString text = list->getItemText(n);
+  if (text.length() && len > 0) {
+    strncpy(value, text.text(), len);
+    value[len - 1] = '\0';
+  } else {
+    value[0] = '\0';
+  }
+}
+
+void ListBoxFox::RegisterImage(int type, const char *xpm_data)
+{
+  FXXPMIcon * icon = new FXXPMIcon(FXApp::instance(), &xpm_data);
+  icon->create();
+  if (!pixhash)
+    pixhash = new map<int, FXXPMIcon *>;
+  FXXPMIcon * old = (*pixhash)[type];
+  if (old)
+    delete old;
+  (*pixhash)[type] = icon;
+}
+
+void ListBoxFox::ClearRegisteredImages()
+{
+  if (pixhash) {
+    map<int, FXXPMIcon *>::iterator it;
+    for (it = pixhash->begin(); it != pixhash->end(); it++) {
+      delete (*it).second;
+    }
+    delete pixhash;
+  }  
+}
+
+void ListBoxFox::SetList(const char* items, char separator, char typesep) {
+  Clear();
+  int count = strlen(items) + 1;
+  char *words = new char[count];
+  if (words) {
+    memcpy(words, items, count);
+    char *startword = words;
+    char *numword = NULL;
+    int i = 0;
+    for (; words[i]; i++) {
+      if (words[i] == separator) {
+        words[i] = '\0';
+        if (numword)
+          *numword = '\0';
+        Append(startword, numword?atoi(numword + 1):-1);
+        startword = words + i + 1;
+        numword = NULL;
+      } else if (words[i] == typesep) {
+        numword = words + i;
+      }
+    }
+    if (startword) {
+      if (numword)
+        *numword = '\0';
+      Append(startword, numword?atoi(numword + 1):-1);
+    }
+    delete []words;
+  }
+  list->sortItems();
+}
+
+void ListBoxFox::RegisterRGBAImage(int type, int width, int height, const unsigned char *pixelsImage) {
+
+}
+
+
+// ====================================================================
+// ListBox
+// ====================================================================
+
+ListBox::ListBox()
+{
+}
+
+ListBox::~ListBox()
+{
+}
+
+ListBox * ListBox::Allocate()
+{
+  return new ListBoxFox();
+}
+
+
+// ====================================================================
+// Menu
+// ====================================================================
+
+Menu::Menu() : mid(0) {}
+
+
+void Menu::CreatePopUp() {
+  Destroy();
+  mid = new FXMenuPane(FXApp::instance()->getCursorWindow());
+}
+
+void Menu::Destroy() {
+  if (mid)
+    delete mid;
+  mid = 0;
+}
+
+void Menu::Show(Point pt, Window &) {
+  int screenHeight = FXApp::instance()->getRootWindow()->getDefaultHeight();
+  int screenWidth = FXApp::instance()->getRootWindow()->getDefaultWidth();
+  mid->create();
+  if ((pt.x + mid->getWidth()) > screenWidth) {
+    pt.x = screenWidth - mid->getWidth();
+  }
+  if ((pt.y + mid->getHeight()) > screenHeight) {
+    pt.y = screenHeight - mid->getHeight();
+  }
+  mid->popup(NULL, pt.x - 4, pt.y - 2);
+  mid->grabKeyboard();
+  FXApp::instance()->runModalWhileShown(mid);
+}
+
+#ifndef WIN32
+
+ElapsedTime::ElapsedTime() {
+  timeval curTime;
+  gettimeofday(&curTime, NULL);
+  bigBit = curTime.tv_sec;
+  littleBit = curTime.tv_usec;
+}
+
+double ElapsedTime::Duration(bool reset) {
+  timeval curTime;
+  gettimeofday(&curTime, NULL);
+  long endBigBit = curTime.tv_sec;
+  long endLittleBit = curTime.tv_usec;
+  double result = 1000000.0 * (endBigBit - bigBit);
+  result += endLittleBit - littleBit;
+  result /= 1000000.0;
+  if (reset) {
+    bigBit = endBigBit;
+    littleBit = endLittleBit;
+  }
+  return result;
+}
+
+#else  // WIN32
+
+static bool initialisedET = false;
+static bool usePerformanceCounter = false;
+static LARGE_INTEGER frequency;
+
+ElapsedTime::ElapsedTime() {
+  if (!initialisedET) {
+    usePerformanceCounter = ::QueryPerformanceFrequency(&frequency);
+    initialisedET = true;
+  }
+  if (usePerformanceCounter) {
+    LARGE_INTEGER timeVal;
+    ::QueryPerformanceCounter(&timeVal);
+    bigBit = timeVal.HighPart;
+    littleBit = timeVal.LowPart;
+  } else {
+    bigBit = clock();
+  }
+}
+
+double ElapsedTime::Duration(bool reset) {
+  double result;
+  long endBigBit;
+  long endLittleBit;
+
+  if (usePerformanceCounter) {
+    LARGE_INTEGER lEnd;
+    ::QueryPerformanceCounter(&lEnd);
+    endBigBit = lEnd.HighPart;
+    endLittleBit = lEnd.LowPart;
+    LARGE_INTEGER lBegin;
+    lBegin.HighPart = bigBit;
+    lBegin.LowPart = littleBit;
+    double elapsed = lEnd.QuadPart - lBegin.QuadPart;
+    result = elapsed / static_cast<double>(frequency.QuadPart);
+  } else {
+    endBigBit = clock();
+    endLittleBit = 0;
+    double elapsed = endBigBit - bigBit;
+    result = elapsed / CLOCKS_PER_SEC;
+  }
+  if (reset) {
+    bigBit = endBigBit;
+    littleBit = endLittleBit;
+  }
+  return result;
+}
+#endif  // WIN32
+
+// ====================================================================
+// Dynamic library handling.
+// - fxdllXxx API with Fox >= 1.2
+// ====================================================================
+
+// Fox >= 1.2 has dynamic librarie handling
+
+
+#include <FXDLL.h>
+
+#ifdef FOX_1_6
+class DynamicLibraryImpl : public DynamicLibrary {
+protected:
+  void * m;
+public:
+  DynamicLibraryImpl(const char *modulePath) {
+    m = fxdllOpen(modulePath);
+  }
+
+  virtual ~DynamicLibraryImpl() {
+    if (m != NULL)
+      fxdllClose(m);
+  }
+
+  // Use lt_dlsym to get a pointer to the relevant function.
+  virtual Function FindFunction(const char *name) {
+    if (m != NULL) {
+      return fxdllSymbol(m, name);
+    } else
+      return NULL;
+  }
+
+  virtual bool IsValid() {
+    return m != NULL;
+  }
+};
+#else
+class DynamicLibraryImpl : public DynamicLibrary {
+protected:
+  FXDLL*dll;
+public:
+  DynamicLibraryImpl(const char *modulePath) {
+      dll=new FXDLL();
+    dll->load(modulePath);
+  }
+
+  virtual ~DynamicLibraryImpl() {
+    dll->unload();
+    delete dll;
+  }
+
+
+  // Use lt_dlsym to get a pointer to the relevant function.
+  virtual Function FindFunction(const char *name) {
+    if (dll->loaded()) {
+      return dll->address(name);
+    } else
+      return NULL;
+  }
+
+  virtual bool IsValid() {
+    return dll->loaded();
+  }
+};
+#endif
+
+
+DynamicLibrary *DynamicLibrary::Load(const char *modulePath) {
+  return static_cast<DynamicLibrary *>( new DynamicLibraryImpl(modulePath) );
+}
+
+
+// ====================================================================
+// Platform
+// ====================================================================
+
+ColourDesired Platform::Chrome() {
+  return ColourDesired(0xe0, 0xe0, 0xe0);
+}
+
+ColourDesired Platform::ChromeHighlight() {
+  return ColourDesired(0xff, 0xff, 0xff);
+}
+
+const char *Platform::DefaultFont() {
+  static FXString fontName;
+  fontName = FXApp::instance()->getNormalFont()->getName();
+  return fontName.text();
+}
+
+int Platform::DefaultFontSize() {
+  // Warning: FOX gives the font size in deci-point
+  return FXApp::instance()->getNormalFont()->getSize() / 10;
+}
+
+unsigned int Platform::DoubleClickTime() {
+  return 500;   // Half a second
+}
+
+bool Platform::MouseButtonBounce() {
+  return true; // <FIXME/> same as gtk?
+}
+
+void Platform::DebugDisplay(const char *s) {
+  printf("%s", s);
+}
+
+bool Platform::IsKeyDown(int) {
+  // TODO: discover state of keys in GTK+/X
+  return false;
+}
+
+/* These methods are now implemented in ScintillaFOX.cxx
+long Platform::SendScintilla(WindowID w, unsigned int msg,
+                             unsigned long wParam, long lParam) {
+  return static_cast<FXScintilla *>(w)->sendMessage(msg, wParam, lParam);
+}
+long Platform::SendScintillaPointer(WindowID w, unsigned int msg,
+                                    unsigned long wParam, void *lParam) {
+  return static_cast<FXScintilla *>(w)->
+    sendMessage(msg, wParam, reinterpret_cast<sptr_t>(lParam));
+}
+*/
+
+bool Platform::IsDBCSLeadByte(int /*codePage*/, char /*ch*/) {
+  return false;
+}
+
+int Platform::DBCSCharLength(int /*codePage*/, const char *s) {
+  int bytes = mblen(s, MB_CUR_MAX);
+  if (bytes >= 1)
+    return bytes;
+  else
+    return 1;
+}
+
+int Platform::DBCSCharMaxLength() {
+  return MB_CUR_MAX;
+}
+
+// These are utility functions not really tied to a platform
+
+int Platform::Minimum(int a, int b) {
+  if (a < b)
+    return a;
+  else
+    return b;
+}
+
+int Platform::Maximum(int a, int b) {
+  if (a > b)
+    return a;
+  else
+    return b;
+}
+
+//#define TRACE
+
+#ifdef TRACE
+void Platform::DebugPrintf(const char *format, ...) {
+  char buffer[2000];
+  va_list pArguments;
+  va_start(pArguments, format);
+  vsprintf(buffer, format, pArguments);
+  va_end(pArguments);
+  Platform::DebugDisplay(buffer);
+}
+#else
+void Platform::DebugPrintf(const char *, ...) {
+}
+#endif
+
+// Not supported for GTK+
+static bool assertionPopUps = true;
+
+bool Platform::ShowAssertionPopUps(bool assertionPopUps_) {
+  bool ret = assertionPopUps;
+  assertionPopUps = assertionPopUps_;
+  return ret;
+}
+
+void Platform::Assert(const char *c, const char *file, int line) {
+  char buffer[2000];
+  sprintf(buffer, "Assertion [%s] failed at %s %d", c, file, line);
+  strcat(buffer, "\r\n");
+  Platform::DebugDisplay(buffer);
+  abort();
+}
+
+int Platform::Clamp(int val, int minVal, int maxVal) {
+  if (val > maxVal)
+    val = maxVal;
+  if (val < minVal)
+    val = minVal;
+  return val;
+}
diff -NaurB scintilla-3.5.2/fox/ScintillaFOX.cxx scintilla-3.5.2-fox/fox/ScintillaFOX.cxx
--- scintilla-3.5.2/fox/ScintillaFOX.cxx	1970-01-01 01:00:00.000000000 +0100
+++ scintilla-3.5.2-fox/fox/ScintillaFOX.cxx	2014-12-04 12:30:18.000000000 +0100
@@ -0,0 +1,1565 @@
+/** FXScintilla source code edit control
+ *
+ *  ScintillaFOX.cxx - FOX toolkit specific subclass of ScintillaBase
+ *
+ *  Copyright 2001-2004 by Gilles Filippini <gilles.filippini@free.fr>
+ *
+ *  Adapted from the Scintilla source ScintillaGTK.cxx 
+ *  Copyright 1998-2004 by Neil Hodgson <neilh@scintilla.org>
+ *
+ *  ====================================================================
+ *
+ *  This file is part of FXScintilla.
+ * 
+ *  FXScintilla is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU Lesser General Public License as published by
+ *  the Free Software Foundation; either version 2.1 of the License, or
+ *  (at your option) any later version.
+ *
+ *  FXScintilla is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public License
+ *  along with FXScintilla; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ **/
+
+#include <stdlib.h>
+#include <string.h>
+#include <stdio.h>
+#include <ctype.h>
+#include <time.h>
+#include <string>
+#include <vector>
+#include <map>
+#include <algorithm>
+#include <stdexcept>
+
+#if !defined(WIN32) || defined(__CYGWIN__)
+# if defined(__CYGWIN__)
+#  include <windows.h>
+#  ifdef PIC
+#   define FOXDLL
+#  endif
+# endif
+# include <fx.h>
+# include <fxkeys.h>
+#else
+# if defined(__MINGW32__) 
+#  include <windows.h>
+#  if defined(PIC) && !defined(FOXDLL)
+#    define FOXDLL
+#  endif
+# endif
+# include <fx.h>
+# include <fxkeys.h>
+#endif  // !defined(WIN32) || defined(__CYGWIN__)
+
+#include "Platform.h"
+
+#include "XPM.h"
+
+#include "Scintilla.h"
+#include "ScintillaWidget.h"
+#ifdef SCI_LEXER
+# include "SciLexer.h"
+# include "ILexer.h"
+# include "LexerModule.h"
+# include "ExternalLexer.h"
+#endif
+#include "SplitVector.h"
+#include "Partitioning.h"
+#include "RunStyles.h"
+#include "ContractionState.h"
+#include "CellBuffer.h"
+#include "CallTip.h"
+#include "KeyMap.h"
+#include "Indicator.h"
+#include "LineMarker.h"
+#include "Style.h"
+#include "AutoComplete.h"
+#include "ViewStyle.h"
+#include "CharClassify.h"
+#include "Decoration.h"
+#include "CaseFolder.h"
+#include "Document.h"
+#include "Selection.h"
+#include "PositionCache.h"
+#include "EditModel.h"
+#include "MarginView.h"
+#include "EditView.h"
+#include "Editor.h"
+#include "ScintillaBase.h"
+
+#ifdef WIN32
+#ifdef FOXDLL
+#undef FXAPI
+#define FXAPI __declspec(dllexport)
+#endif
+#endif
+#include "FXScintilla.h"
+
+#ifdef _MSC_VER
+// Constant conditional expressions are because of GTK+ headers
+#pragma warning(disable: 4127)
+#endif
+
+#include <FX88591Codec.h>
+
+#include "version.h"
+
+// ====================================================================
+// ScintillaFOX
+// ====================================================================
+class ScintillaFOX : public ScintillaBase {
+  friend class FXScintilla;
+protected:
+  FXScintilla & _fxsc;
+  bool tryDrag;
+  bool dragWasDropped;
+  Point ptMouseLastBeforeDND;
+
+  // Because clipboard access is asynchronous, copyText is created by Copy
+  SelectionText copyText;
+  SelectionText primary;
+  
+  // Vertical scrollbar handling
+  int vsbMax;
+  int vsbPage;
+  
+  // Flag to prevent infinite loop with moveContents
+  bool inMoveContents;
+public:
+  ScintillaFOX(FXScintilla & fxsc);
+  virtual ~ScintillaFOX();
+  virtual sptr_t WndProc(unsigned int iMessage, uptr_t wParam, sptr_t lParam);
+private:
+  int TargetAsUTF8(char *text);
+  int EncodedFromUTF8(char *utf8, char *encoded);
+  // Virtual methods from ScintillaBase
+  virtual void Initialise();
+  virtual void Finalise();
+  virtual void DisplayCursor(Window::Cursor c);
+  virtual void SetVerticalScrollPos();
+  virtual void SetHorizontalScrollPos();
+  virtual void CopyToClipboard(const SelectionText &selectedText);
+  virtual void Copy();
+  virtual void Paste();
+  virtual void ClaimSelection();
+  virtual void NotifyChange();
+  virtual void NotifyParent(SCNotification scn);
+  FXSelector TickReasonToSel(TickReason reason);
+  TickReason SelToTickReason(FXSelector sel);
+  virtual bool FineTickerAvailable();
+  virtual bool FineTickerRunning(TickReason reason);
+  virtual void FineTickerStart(TickReason reason, int millis, int tolerance);
+  virtual void FineTickerCancel(TickReason reason);
+  virtual bool SetIdle(bool on);
+  virtual void QueueIdleWork(WorkNeeded::workItems items, int upTo);
+  virtual void SetMouseCapture(bool on);
+  virtual bool HaveMouseCapture();
+  virtual bool PaintContains(PRectangle rc);
+  virtual sptr_t DefWndProc(unsigned int iMessage, uptr_t wParam, sptr_t lParam);
+  virtual void CreateCallTipWindow(PRectangle rc);
+  virtual void AddToPopUp(const char * label, int cmd = 0, bool enabled = true);
+  virtual void StartDrag();
+  virtual bool ValidCodePage(int codePage) const;
+  //
+  static sptr_t DirectFunction(ScintillaFOX *sciThis, 
+    unsigned int iMessage, uptr_t wParam, sptr_t lParam);
+  // Paint
+  void SyncPaint(PRectangle rc);
+  void FullPaint();
+  void UnclaimSelection();
+  void ReceivedSelection(FXDNDOrigin origin, int atPos);
+  void NotifyKey(int key, int modifiers);
+  void NotifyURIDropped(const char *list);
+  
+  // From ScintillaBase
+  virtual bool ModifyScrollBars(int nMax, int nPage);
+  virtual void ReconfigureScrollBars();
+  virtual PRectangle GetClientRectangle() const;
+  virtual int KeyDefault(int key, int modifiers);
+
+  // Popup flag
+  bool getDisplayPopupMenu() const { return displayPopupMenu; }
+};
+
+ScintillaFOX::ScintillaFOX(FXScintilla & fxsc) :
+  _fxsc(fxsc),
+  tryDrag(false),
+  dragWasDropped(false),
+  vsbMax(0),
+  vsbPage(0),
+  inMoveContents(false)
+{
+  wMain = &_fxsc;
+  Initialise();
+}
+
+ScintillaFOX::~ScintillaFOX()
+{
+  Finalise();
+}
+
+int ScintillaFOX::TargetAsUTF8(char *text) {
+  (void)text;
+  // TODO
+  // Fail
+  return 0;
+}
+
+int ScintillaFOX::EncodedFromUTF8(char *utf8, char *encoded) {
+  (void)utf8;
+  (void)encoded;
+  // TODO
+  // Fail
+  return 0;
+}
+
+bool ScintillaFOX::ValidCodePage(int codePage) const {
+  return codePage == 0
+  || codePage == SC_CP_UTF8
+  || codePage == 932
+  || codePage == 936
+  || codePage == 949
+  || codePage == 950
+  || codePage == 1361;
+}
+
+sptr_t ScintillaFOX::WndProc(unsigned int iMessage, uptr_t wParam, sptr_t lParam) {
+  switch (iMessage) {
+
+  case SCI_GRABFOCUS:
+    _fxsc.setFocus();
+    break;
+
+  case SCI_GETDIRECTFUNCTION:
+    return reinterpret_cast<sptr_t>(DirectFunction);
+  
+  case SCI_GETDIRECTPOINTER:
+    return reinterpret_cast<sptr_t>(this);
+
+#ifdef SCI_LEXER
+  case SCI_LOADLEXERLIBRARY:
+    LexerManager::GetInstance()->Load(reinterpret_cast<const char*>(wParam));
+    break;
+#endif
+  case SCI_TARGETASUTF8:
+    return TargetAsUTF8(reinterpret_cast<char*>(lParam));
+
+  case SCI_ENCODEDFROMUTF8:
+    return EncodedFromUTF8(reinterpret_cast<char*>(wParam), 
+      reinterpret_cast<char*>(lParam));
+
+  default:
+    return ScintillaBase::WndProc(iMessage,wParam,lParam);
+  }
+  return 0l;
+}
+
+void ScintillaFOX::ClaimSelection()
+{
+  // Acquire selection
+
+// JKP  1.79 if (currentPos != anchor) {
+// JKP 2.00 ? if (SelectionStart().Position() != SelectionEnd().Position()) {
+  if (!sel.Empty()) { // <- JKP 2.00
+    _fxsc.acquireSelection(&FXWindow::stringType,1);
+    primarySelection = true;
+    primary.Clear();
+  }
+  else {
+//  _fxsc.releaseSelection(); // JKP:  Does not work for 2.00 - Do we need somethong else?
+  }
+}
+
+void ScintillaFOX::UnclaimSelection()
+{
+  //Platform::DebugPrintf("UnclaimPrimarySelection\n");
+  if (!_fxsc.hasSelection()) {
+    primary.Clear();
+    primarySelection = false;
+    FullPaint();
+  }
+}
+
+#ifdef WIN32
+static CLIPFORMAT cfColumnSelect()
+{
+  static CLIPFORMAT cf = static_cast<CLIPFORMAT>(::RegisterClipboardFormat("MSDEVColumnSelect"));
+  return cf;
+}
+#endif
+
+#define InUTF8Mode(sf) (sf->CodePage()==SC_CP_UTF8)
+
+// JKP: Heavily reworked to fix middle-click-paste when current document has the X-selection.
+// JKP: Still more reworking for 2.00!
+void ScintillaFOX::ReceivedSelection(FXDNDOrigin origin, int atPos)
+{
+  FXuchar *data=NULL;
+  FXuint len=0;
+  if (pdoc->IsReadOnly()) { return; }
+  if (InUTF8Mode(this)&&_fxsc.getDNDData(origin, FXWindow::utf8Type, data, len)) {
+    /* If the data and the scintilla are both UTF-8, then no conversion is needed. */
+  } else {
+    if(_fxsc.getDNDData(origin, FXWindow::stringType, data, len)) {
+      if (InUTF8Mode(this)) {
+        for (FXuint i=0; i<len; i++) {
+          if ((FXuchar)(data[i])>126) { // We are in UTF-8 mode, but the data is extended ASCII
+            FX88591Codec asciiCodec;
+            FXString codecBuffer;
+            codecBuffer.length(asciiCodec.mb2utflen((FXchar*)data,len));
+            asciiCodec.mb2utf(&(codecBuffer.at(0)),codecBuffer.length(),(FXchar*)data,len);
+            FXRESIZE(&data,FXuchar,codecBuffer.length());
+            memcpy(data, codecBuffer.text(),codecBuffer.length());
+            len=codecBuffer.length();
+            break;
+          }
+        }
+      } 
+    } else { // Type of DND data must be something we don't know how to deal with.
+      return;
+    }
+  }
+  FXRESIZE(&data,FXuchar,len+1);
+  data[len]='\0';
+  bool isRectangular;
+  SelectionText selText;
+
+#ifdef WIN32
+  len=0;
+  while(data[len]) { len++; }
+  isRectangular = ::IsClipboardFormatAvailable(cfColumnSelect()) != 0;
+#else // !WIN32
+  isRectangular = ((len > 2) && (data[len - 1] == 0 && data[len - 2] == '\n'));
+#endif // WIN32
+
+  std::string dest = Document::TransformLineEnds((char*)data, len, pdoc->eolMode);
+  selText.Copy(dest.c_str(), CodePage(), 0, isRectangular, false);
+  pdoc->BeginUndoAction();
+
+  if(_fxsc.hasSelection() && (origin == FROM_CLIPBOARD)) { ClearSelection(); }
+
+  SelectionPosition selStart = sel.IsRectangular() ?
+	  sel.Rectangular().Start() :
+	  sel.Range(sel.Main()).Start();
+
+  if (selText.rectangular) {
+    PasteRectangular(selStart, selText.Data(), selText.Length());
+  } else {
+    if (atPos<0) {
+      selStart = SelectionPosition(InsertSpace(selStart.Position(), selStart.VirtualSpace()));
+      if (pdoc->InsertString(selStart.Position(),selText.Data(), selText.Length())) {
+        SetEmptySelection( (selStart.Position()) + selText.Length() );
+      }
+    } else {  
+      if (pdoc->InsertString(atPos,selText.Data(), selText.Length())) {
+        SetEmptySelection(atPos+selText.Length());
+        FullPaint();
+      }
+    }
+  }
+  pdoc->EndUndoAction();
+  EnsureCaretVisible();
+//  _fxsc.setDNDData(origin, FXWindow::stringType, data, len);
+  FXFREE(&data);
+}
+
+
+void ScintillaFOX::NotifyKey(int key, int modifiers) {
+  SCNotification scn;
+  scn.nmhdr.code = SCN_KEY;
+  scn.ch = key;
+  scn.modifiers = modifiers;
+
+  NotifyParent(scn);
+}
+
+void ScintillaFOX::NotifyURIDropped(const char *list) {
+  SCNotification scn;
+  scn.nmhdr.code = SCN_URIDROPPED;
+  scn.text = list;
+
+  NotifyParent(scn);
+}
+
+int ScintillaFOX::KeyDefault(int key, int modifiers) {
+  if (!(modifiers & SCI_CTRL) && !(modifiers & SCI_ALT) && (key < 256)) {
+    //NotifyKey(key, modifiers);
+    //return 0;
+    AddChar(key);
+    return 1;
+  } else {
+    // Pass up to container in case it is an accelerator
+    NotifyKey(key, modifiers);
+    return 0;
+  }
+  //Platform::DebugPrintf("SK-key: %d %x %x\n",key, modifiers);
+}
+
+// ********************************************************************
+
+void ScintillaFOX::Initialise()
+{
+}
+
+void ScintillaFOX::Finalise()
+{
+  for (TickReason tr = tickCaret; tr <= tickDwell; tr = static_cast<TickReason>(tr + 1)) {
+    FineTickerCancel(tr);
+  }
+  ScintillaBase::Finalise();
+}
+
+void ScintillaFOX::DisplayCursor(Window::Cursor c) {
+  if (cursorMode == SC_CURSORNORMAL)
+    wMain.SetCursor(c);
+  else
+    wMain.SetCursor(static_cast<Window::Cursor>(cursorMode));
+}
+
+void ScintillaFOX::SetVerticalScrollPos()
+{
+  if (inMoveContents) return;
+  // Update the scrollbar position only if this method is not called by
+  // moveContents (to prevent an infinite loop becaude setPosition
+  // triggers moveContents).
+  // BTW scrollbar should be up to date when in movecontents.
+  DwellEnd(true);
+#ifdef FOX_1_6
+    _fxsc.setPosition(_fxsc.getXPosition(), -topLine * vs.lineHeight);
+#else
+    FXint gpx,gpy;
+    _fxsc.getPosition(gpx,gpy);
+    _fxsc.setPosition(gpx, -topLine * vs.lineHeight);
+#endif
+}
+
+void ScintillaFOX::SetHorizontalScrollPos()
+{
+  if (inMoveContents) return;
+  // Update the scrollbar position only if this method is not called by
+  // moveContents (to prevent an infinite loop becaude setPosition
+  // triggers moveContents).
+  // BTW scrollbar should be up to date when in movecontents.
+  DwellEnd(true);
+#ifdef FOX_1_6
+  _fxsc.setPosition(-xOffset, _fxsc.getYPosition());
+#else
+  FXint gpx,gpy;
+  _fxsc.getPosition(gpx,gpy);
+  _fxsc.setPosition(-xOffset, gpy);
+#endif
+}
+
+void ScintillaFOX::CopyToClipboard(const SelectionText &selectedText) {
+  if (_fxsc.acquireClipboard(&FXWindow::stringType, 1)) {
+    copyText.Copy(selectedText);
+  }
+}
+
+#ifdef WIN32
+void ScintillaFOX::Copy()
+{
+  if (_fxsc.hasSelection()) {
+    FXDragType dt[2] = { 
+      FXWindow::stringType,
+      sel.selType==Selection::selRectangle ? cfColumnSelect() : (FXDragType)0
+    };
+    if (_fxsc.acquireClipboard(dt, dt[1]?2:1)) {
+      CopySelectionRange(&copyText);
+    }
+  } else {
+    _fxsc.releaseClipboard();
+  }
+}
+#else
+void ScintillaFOX::Copy()
+{
+  if (_fxsc.hasSelection()) {
+    if (_fxsc.acquireClipboard(&FXWindow::stringType, 1)) {
+      CopySelectionRange(&copyText);
+    }
+  }
+  else {
+    _fxsc.releaseClipboard();
+  }
+}
+#endif
+
+void ScintillaFOX::Paste()
+{
+  ReceivedSelection(FROM_CLIPBOARD, -1);
+}
+
+void ScintillaFOX::NotifyChange()
+{
+  _fxsc.handle(&_fxsc, MKUINT(0, SEL_CHANGED), NULL);
+}
+
+void ScintillaFOX::NotifyParent(SCNotification scn)
+{
+  scn.nmhdr.hwndFrom = wMain.GetID();
+  scn.nmhdr.idFrom = GetCtrlID();
+  _fxsc.handle(&_fxsc, MKUINT(0, SEL_COMMAND), &scn);
+}
+
+FXSelector ScintillaFOX::TickReasonToSel(TickReason reason)
+{
+  switch (reason) {
+    case tickCaret:    return FXScintilla::ID_TICK_CARET;
+    case tickScroll:   return FXScintilla::ID_TICK_SCROLL;
+    case tickWiden:    return FXScintilla::ID_TICK_WIDEN;
+    case tickDwell:    return FXScintilla::ID_TICK_DWELL;
+    case tickPlatform: return FXScintilla::ID_TICK_PLATFORM;
+    default: return 0;
+  }
+}
+
+ScintillaFOX::TickReason ScintillaFOX::SelToTickReason(FXSelector sel)
+{
+  switch (sel) {
+    case FXScintilla::ID_TICK_CARET:    return tickCaret;
+    case FXScintilla::ID_TICK_SCROLL:   return tickScroll;
+    case FXScintilla::ID_TICK_WIDEN:    return tickWiden;
+    case FXScintilla::ID_TICK_DWELL:    return tickDwell;
+    case FXScintilla::ID_TICK_PLATFORM: return tickPlatform;
+    default: return tickCaret;
+  }
+}
+
+bool ScintillaFOX::FineTickerAvailable()
+{
+  return true;
+}
+
+bool ScintillaFOX::FineTickerRunning(TickReason reason)
+{
+  return FXApp::instance()->hasTimeout(&_fxsc, TickReasonToSel(reason));
+}
+
+void ScintillaFOX::FineTickerStart(TickReason reason, int millis, int tolerance)
+{
+  (void)tolerance;
+  FineTickerCancel(reason);
+#ifdef FOX_1_6
+  FXApp::instance()->addTimeout(&_fxsc, TickReasonToSel(reason), millis, (void*)(FXival)millis);
+#else
+  FXApp::instance()->addTimeout(&_fxsc, TickReasonToSel(reason), millis*1000000, (void*)(FXival)millis);
+#endif
+}
+
+void ScintillaFOX::FineTickerCancel(TickReason reason)
+{
+  FXApp::instance()->removeTimeout(&_fxsc, TickReasonToSel(reason));
+}
+
+bool ScintillaFOX::SetIdle(bool on) {
+  if (on) {
+    // Start idler, if it's not running.
+    if (idler.state == false) {
+      idler.state = true;
+      FXApp::instance()->addChore(&_fxsc, FXScintilla::ID_IDLE);
+    }
+  } else {
+    // Stop idler, if it's running
+    if (idler.state == true) {
+      idler.state = false;
+      FXApp::instance()->removeChore(&_fxsc, FXScintilla::ID_IDLE);
+    }
+  }
+  return true;
+}
+
+void ScintillaFOX::QueueIdleWork(WorkNeeded::workItems items, int upTo) {
+  Editor::QueueIdleWork(items, upTo);
+  if (!workNeeded.active) {
+    // Only allow one style needed to be queued
+    workNeeded.active = true;
+    FXApp::instance()->addChore(&_fxsc, FXScintilla::ID_STYLE_IDLE);
+  }
+}
+
+void ScintillaFOX::SetMouseCapture(bool on)
+{
+  if (mouseDownCaptures) {
+    if (on) {
+      _fxsc.grab();
+    } else {
+      _fxsc.ungrab();
+    }
+  }
+}
+
+bool ScintillaFOX::HaveMouseCapture()
+{
+  return _fxsc.grabbed();
+}
+
+bool ScintillaFOX::PaintContains(PRectangle rc) {
+  bool contains = true;
+  if (paintState == painting) {
+    if (!rcPaint.Contains(rc)) {
+      contains = false;
+    }
+  }
+  return contains;
+}
+
+void ScintillaFOX::StartDrag()
+{
+  tryDrag = true;
+  dragWasDropped = false;
+}
+
+sptr_t ScintillaFOX::DefWndProc(unsigned int, uptr_t, sptr_t)
+{
+  return 0;
+}
+
+
+// JKP: A new class, overrides the onPaint() method to 
+// let a CallTip object take over the painting.
+class CallTipWindow:public FXFrame {
+  FXDECLARE(CallTipWindow)
+  CallTipWindow(){}
+protected:
+  CallTip*ct;
+public:
+  long onPaint(FXObject*o, FXSelector sel, void*p);
+  CallTipWindow( FXComposite *p, CallTip*_ct):FXFrame(p,FRAME_NONE|LAYOUT_FILL),ct(_ct) {}
+};
+
+FXDEFMAP(CallTipWindow) CallTipWindowMap[] = {
+  FXMAPFUNC(SEL_PAINT,0,CallTipWindow::onPaint)
+};
+
+FXIMPLEMENT(CallTipWindow,FXFrame,CallTipWindowMap,ARRAYNUMBER(CallTipWindowMap));
+
+long CallTipWindow::onPaint(FXObject*o, FXSelector sel, void*p)
+{
+  long rv=FXFrame::onPaint(o,sel,p);  
+  Surface *surfaceWindow = Surface::Allocate(SC_TECHNOLOGY_DEFAULT);
+  if (surfaceWindow) {
+    surfaceWindow->Init(this, this);
+    surfaceWindow->SetUnicodeMode(SC_CP_UTF8 == ct->codePage);
+    surfaceWindow->SetDBCSMode(ct->codePage);
+    ct->PaintCT(surfaceWindow);
+    surfaceWindow->Release();
+    delete surfaceWindow;
+  }
+  return rv;
+}
+
+
+void ScintillaFOX::CreateCallTipWindow(PRectangle  rc )
+{
+  // Gilles says: <FIXME/>
+  // JKP says: OK, I'll try....
+  if (!ct.wCallTip.GetID()) {
+    FXHorizontalFrame*w=new FXHorizontalFrame(&_fxsc,FRAME_NONE,rc.left, rc.top, 
+      (rc.right-rc.left), (rc.bottom-rc.top),0,0,0,0,0,0);
+    CallTipWindow*c=new CallTipWindow(w, &ct);
+    w->create();
+    ct.wCallTip=w;
+    ct.wDraw=c;
+  }
+}
+
+
+
+class PopUpCmd: public FXMenuCommand {
+  FXDECLARE(PopUpCmd)
+  PopUpCmd() {}
+  protected:
+#ifdef FOX_1_6
+ FXlong CreationTime;
+#else
+ FXTime CreationTime;
+#endif
+public:
+  PopUpCmd(FXComposite* p,const FXString& text,FXIcon* ic,FXObject* tgt,FXSelector sel):
+     FXMenuCommand(p,text,ic,tgt,sel), CreationTime(FXThread::time()) { }
+  long onButtonRelease(FXObject*o,FXSelector sel,void*p) {
+    return (FXThread::time()-CreationTime)<500000000 ? 1 : FXMenuCommand::onButtonRelease(o,sel,p);
+  }
+};
+FXDEFMAP(PopUpCmd) PopUpCmdMap[]={ FXMAPFUNC(SEL_RIGHTBUTTONRELEASE,0,PopUpCmd::onButtonRelease) };
+FXIMPLEMENT(PopUpCmd,FXMenuCommand,PopUpCmdMap,ARRAYNUMBER(PopUpCmdMap));
+
+
+
+void ScintillaFOX::AddToPopUp(const char * label, int cmd, bool enabled)
+{
+  if (label[0]) {
+    PopUpCmd* item = new PopUpCmd(static_cast<FXComposite *>(popup.GetID()), label, NULL, &_fxsc, SCID(cmd));
+    if (!enabled)
+      item->disable();
+  }
+  else
+    new FXMenuSeparator(static_cast<FXComposite *>(popup.GetID()));
+}
+
+sptr_t ScintillaFOX::DirectFunction(
+    ScintillaFOX *sciThis, unsigned int iMessage, uptr_t wParam, sptr_t lParam) {
+  return sciThis->WndProc(iMessage, wParam, lParam);
+}
+
+PRectangle ScintillaFOX::GetClientRectangle() const {
+  // Have to call FXScrollArea::getViewportXxxx instead of getViewportXxxx
+  // to prevent infinite loop
+#ifdef FOX_1_6
+  PRectangle rc(0, 0, _fxsc.FXScrollArea::getViewportWidth(), _fxsc.FXScrollArea::getViewportHeight());
+  if (_fxsc.horizontalScrollBar()->shown())
+    rc.bottom -= _fxsc.horizontalScrollBar()->getDefaultHeight();
+  if (_fxsc.verticalScrollBar()->shown())
+    rc.right -= _fxsc.verticalScrollBar()->getDefaultWidth();
+#else
+  PRectangle rc(0, 0, _fxsc.FXScrollArea::getVisibleWidth(), _fxsc.FXScrollArea::getVisibleHeight());
+#endif
+  return rc;
+}
+
+void ScintillaFOX::ReconfigureScrollBars()
+{
+  if (horizontalScrollBarVisible)
+    _fxsc.setScrollStyle(_fxsc.getScrollStyle() & ~HSCROLLER_NEVER);
+  else
+    _fxsc.setScrollStyle(_fxsc.getScrollStyle() | HSCROLLER_NEVER);
+  _fxsc.recalc();
+}
+
+bool ScintillaFOX::ModifyScrollBars(int nMax, int nPage)
+{
+  bool modified = false;
+  // There was no vertical scrollbar if
+  //   !vsbMax || (vsbMax < vsbPage)
+  bool noVScroll = !vsbMax || (vsbMax < vsbPage);
+  // There won't be a vertical scrollbar if
+  //   !nMax || (nMax < nPage)
+  bool noVScrollNew = !nMax || (nMax < nPage);
+  if ((nMax != vsbMax) || (nPage != vsbPage)) {
+    vsbMax = nMax;
+    vsbPage = nPage;
+    // Layout if vertical scrollbar should appear or change
+    if (noVScroll != noVScrollNew || !noVScroll) {
+      _fxsc.layout();
+      if (noVScrollNew)
+        ChangeSize();  // Force scrollbar recalc
+      modified = true;
+    }
+  }
+  // Vertical scrollbar
+  int line = vs.lineHeight;
+  if (_fxsc.verticalScrollBar()->getLine() != line) {
+    _fxsc.verticalScrollBar()->setLine(line);
+    modified = true;
+  }
+  // Horizontal scrollbar
+  PRectangle rcText = GetTextRectangle();
+  unsigned int pageWidth = rcText.Width();
+  if ((_fxsc.horizontalScrollBar()->getPage() != int(pageWidth)) ||
+      (_fxsc.horizontalScrollBar()->getLine() != 10)) {
+    _fxsc.horizontalScrollBar()->setPage(pageWidth);
+    _fxsc.horizontalScrollBar()->setLine(10);
+    modified = true;
+  }
+  return modified;
+}
+
+// --------------------------------------------------------------------
+// Synchronously paint a rectangle of the window.
+void ScintillaFOX::SyncPaint(PRectangle rc) {
+  paintState = painting;
+  rcPaint = rc;
+  PRectangle rcClient = GetClientRectangle();
+  paintingAllText = rcPaint.Contains(rcClient);
+  //Platform::DebugPrintf("ScintillaGTK::SyncPaint %0d,%0d %0d,%0d\n",
+  //  rcPaint.left, rcPaint.top, rcPaint.right, rcPaint.bottom);
+  Surface *sw = Surface::Allocate(SC_TECHNOLOGY_DEFAULT);
+  if (sw) {
+    sw->Init(wMain.GetID(), wMain.GetID());
+    Paint(sw, rcPaint);
+    sw->Release();
+    delete sw;
+  }
+  if (paintState == paintAbandoned) {
+    // Painting area was insufficient to cover new styling or brace highlight positions
+    FullPaint();
+  }
+  paintState = notPainting;
+}
+
+// Redraw all of text area. This paint will not be abandoned.
+void ScintillaFOX::FullPaint() {
+  paintState = painting;
+  rcPaint = GetClientRectangle();
+  //Platform::DebugPrintf("ScintillaGTK::FullPaint %0d,%0d %0d,%0d\n",
+  //  rcPaint.left, rcPaint.top, rcPaint.right, rcPaint.bottom);
+  paintingAllText = true;
+  if (wMain.GetID()) {
+    Surface *sw = Surface::Allocate(SC_TECHNOLOGY_DEFAULT);
+    if (sw) {
+      sw->Init(wMain.GetID(), wMain.GetID());
+      Paint(sw, rcPaint);
+      sw->Release();
+      delete sw;
+    }
+  }
+  paintState = notPainting;
+}
+
+// ====================================================================
+long Platform::SendScintilla(
+    WindowID w, unsigned int msg, unsigned long wParam, long lParam) {
+  return static_cast<FXScintilla *>(w)->sendMessage(msg, wParam, lParam);
+}
+
+long Platform::SendScintillaPointer(WindowID w, unsigned int msg,
+                                    unsigned long wParam, void *lParam) {
+  return static_cast<FXScintilla *>(w)->
+    sendMessage(msg, wParam, reinterpret_cast<sptr_t>(lParam));
+}
+
+// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+// FXScintilla
+// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+
+FXDEFMAP(FXScintilla) FXScintillaMap[]={
+  FXMAPFUNCS(SEL_COMMAND, FXScrollArea::ID_LAST, FXScintilla::idLast, FXScintilla::onScintillaCommand),
+  FXMAPFUNC(SEL_COMMAND, 0, FXScintilla::onCommand),
+  FXMAPFUNC(SEL_CHANGED, 0, FXScintilla::onChanged),
+  FXMAPFUNC(SEL_PAINT, 0, FXScintilla::onPaint),
+  FXMAPFUNC(SEL_CONFIGURE,0,FXScintilla::onConfigure),
+  FXMAPFUNC(SEL_TIMEOUT,FXScintilla::ID_TICK_CARET,FXScintilla::onTimeoutTicking),
+  FXMAPFUNC(SEL_TIMEOUT,FXScintilla::ID_TICK_SCROLL,FXScintilla::onTimeoutTicking),
+  FXMAPFUNC(SEL_TIMEOUT,FXScintilla::ID_TICK_WIDEN,FXScintilla::onTimeoutTicking),
+  FXMAPFUNC(SEL_TIMEOUT,FXScintilla::ID_TICK_DWELL,FXScintilla::onTimeoutTicking),
+  FXMAPFUNC(SEL_TIMEOUT,FXScintilla::ID_TICK_PLATFORM,FXScintilla::onTimeoutTicking),
+  FXMAPFUNC(SEL_FOCUSIN,0,FXScintilla::onFocusIn),
+  FXMAPFUNC(SEL_FOCUSOUT,0,FXScintilla::onFocusOut),
+  FXMAPFUNC(SEL_MOTION,0,FXScintilla::onMotion),
+  FXMAPFUNC(SEL_LEFTBUTTONPRESS,0,FXScintilla::onLeftBtnPress),
+  FXMAPFUNC(SEL_LEFTBUTTONRELEASE,0,FXScintilla::onLeftBtnRelease),
+  FXMAPFUNC(SEL_RIGHTBUTTONPRESS,0,FXScintilla::onRightBtnPress),
+  FXMAPFUNC(SEL_MIDDLEBUTTONPRESS,0,FXScintilla::onMiddleBtnPress),
+  FXMAPFUNC(SEL_BEGINDRAG,0,FXScintilla::onBeginDrag),
+  FXMAPFUNC(SEL_DRAGGED,0,FXScintilla::onDragged),
+  FXMAPFUNC(SEL_ENDDRAG,0,FXScintilla::onEndDrag),
+  FXMAPFUNC(SEL_DND_ENTER,0,FXScintilla::onDNDEnter),
+  FXMAPFUNC(SEL_DND_LEAVE,0,FXScintilla::onDNDLeave),
+  FXMAPFUNC(SEL_DND_DROP,0,FXScintilla::onDNDDrop),
+  FXMAPFUNC(SEL_DND_MOTION,0,FXScintilla::onDNDMotion),
+  FXMAPFUNC(SEL_DND_REQUEST,0,FXScintilla::onDNDRequest),
+  FXMAPFUNC(SEL_SELECTION_LOST,0,FXScintilla::onSelectionLost),
+  FXMAPFUNC(SEL_SELECTION_GAINED,0,FXScintilla::onSelectionGained), // JKP
+  FXMAPFUNC(SEL_SELECTION_REQUEST,0,FXScintilla::onSelectionRequest),
+  FXMAPFUNC(SEL_CLIPBOARD_LOST,0,FXScintilla::onClipboardLost),
+  FXMAPFUNC(SEL_CLIPBOARD_GAINED,0,FXScintilla::onClipboardGained), // JKP
+  FXMAPFUNC(SEL_CLIPBOARD_REQUEST,0,FXScintilla::onClipboardRequest),
+  FXMAPFUNC(SEL_KEYPRESS,0,FXScintilla::onKeyPress),
+  FXMAPFUNC(SEL_CHORE,FXScintilla::ID_IDLE,FXScintilla::onChoreIdle),
+  FXMAPFUNC(SEL_CHORE,FXScintilla::ID_STYLE_IDLE,FXScintilla::onChoreStyleIdle),
+};
+
+FXIMPLEMENT(FXScintilla,FXScrollArea,FXScintillaMap,ARRAYNUMBER(FXScintillaMap))
+
+FXScintilla::FXScintilla()
+{
+}
+
+FXScintilla::FXScintilla(FXComposite * p, FXObject * tgt, FXSelector sel,
+    FXuint opts, FXint x, FXint y, FXint w, FXint h) :
+  FXScrollArea(p, opts, x, y, w, h)
+{
+  flags|=FLAG_ENABLED;
+  target = tgt;
+  message = sel;
+  _scint = new ScintillaFOX(*this);
+}
+
+FXScintilla::~FXScintilla()
+{
+  delete _scint;
+}
+
+void FXScintilla::create()
+{
+  FXScrollArea::create();
+  _scint->wMain.SetCursor(Window::cursorArrow);
+  if(!textType){textType=getApp()->registerDragType(textTypeName);}
+  if(!utf8Type){utf8Type=getApp()->registerDragType(utf8TypeName);}
+  if(!urilistType){urilistType=getApp()->registerDragType(urilistTypeName);}
+  dropEnable();
+  if(getApp()->hasInputMethod()){createComposeContext();}
+}
+
+void FXScintilla::destroy()
+{
+  if(getApp()->hasInputMethod()){destroyComposeContext();}
+  FXScrollArea::destroy();
+}
+
+bool FXScintilla::canFocus() const
+{
+  return true;
+}
+
+long FXScintilla::onScintillaCommand(FXObject *, FXSelector sel, void *)
+{
+  _scint->Command(FXSELID(sel)-SCID(0));
+  return 1;
+}
+
+long FXScintilla::onCommand(FXObject *, FXSelector sel, void * ptr)
+{
+  if (target)
+    return target->handle(this, MKUINT(message, FXSELTYPE(sel)), ptr);
+  return 0;
+}
+
+long FXScintilla::onChanged(FXObject *, FXSelector sel, void * ptr)
+{
+  if (target)
+    return target->handle(this, MKUINT(message, FXSELTYPE(sel)), ptr);
+  return 0;
+}
+
+long FXScintilla::onPaint(FXObject *, FXSelector, void * ptr)
+{
+  FXEvent   *ev=(FXEvent*)ptr;
+  PRectangle rcPaint(ev->rect.x, ev->rect.y, ev->rect.x + ev->rect.w - 1, ev->rect.y + ev->rect.h - 1);
+  _scint->SyncPaint(rcPaint);
+  return 1;
+}
+
+long FXScintilla::onTimeoutTicking(FXObject *o, FXSelector sel, void *p)
+{
+  (void)o;
+#ifdef FOX_1_6
+  FXApp::instance()->addTimeout(this, FXSELID(sel), (FXint)(FXival)p, p);
+#else
+  FXApp::instance()->addTimeout(this, FXSELID(sel), ((FXint)(FXival)p)*1000000, p);
+#endif
+  _scint->TickFor(_scint->SelToTickReason(FXSELID(sel)));
+  return 0;
+}
+
+long FXScintilla::onChoreIdle(FXObject *, FXSelector, void *)
+{
+  // Idler will be automatically stoped, if there is nothing
+  // to do while idle.
+  bool ret = _scint->Idle();
+  if (ret == false) {
+    _scint->SetIdle(false);
+  } else {
+    FXApp::instance()->addChore(this, FXScintilla::ID_IDLE);
+  }
+  return 0;
+}
+
+long FXScintilla::onChoreStyleIdle(FXObject *, FXSelector, void *)
+{
+  // Idler will be automatically stopped
+  _scint->IdleWork();
+  return 1;
+}
+
+long FXScintilla::onFocusIn(FXObject * sender, FXSelector sel, void * ptr)
+{
+  FXScrollArea::onFocusIn(sender, sel, ptr);
+  _scint->SetFocusState(true);
+  return 1;
+}
+
+long FXScintilla::onFocusOut(FXObject * sender, FXSelector sel, void * ptr)
+{
+  FXScrollArea::onFocusOut(sender, sel, ptr);
+  _scint->SetFocusState(false);
+  return 1;
+}
+
+long FXScintilla::onMotion(FXObject *, FXSelector, void * ptr)
+{
+  FXEvent * ev = static_cast<FXEvent *>(ptr);
+  if (_scint->tryDrag) {
+    _scint->tryDrag = false;
+    handle(this, MKUINT(0, SEL_BEGINDRAG), 0);
+  }
+  if (isDragging()) {
+    return handle(this, MKUINT(0, SEL_DRAGGED), ptr);
+  }
+  else {
+    Point pt(ev->win_x, ev->win_y);
+    _scint->ButtonMove(pt);
+  }
+  return 1;
+}
+
+long FXScintilla::onLeftBtnPress(FXObject *, FXSelector, void * ptr)
+{
+//  if (FXScrollArea::onLeftBtnPress(sender, sel, ptr))
+//    return 1;
+  handle(this, MKUINT(0, SEL_FOCUS_SELF), ptr);
+  setFocus();
+  FXEvent * ev = static_cast<FXEvent *>(ptr);
+  Point pt;
+  pt.x = ev->win_x;
+  pt.y = ev->win_y;
+    //sciThis->ButtonDown(pt, event->time,
+    //  event->state & GDK_SHIFT_MASK,
+    //  event->state & GDK_CONTROL_MASK,
+    //  event->state & GDK_MOD1_MASK);
+    // Instead of sending literal modifiers use control instead of alt
+    // This is because all the window managers seem to grab alt + click for moving
+  _scint->ButtonDown(pt, ev->time,
+      ev->state & SHIFTMASK,
+      ev->state & CONTROLMASK,
+      ev->state & CONTROLMASK);
+  return 1;
+}
+
+long FXScintilla::onLeftBtnRelease(FXObject *, FXSelector, void * ptr)
+{
+  if (isDragging())
+    return handle(this, MKUINT(0, SEL_ENDDRAG), ptr);
+  FXEvent * ev = static_cast<FXEvent *>(ptr);
+  Point pt(ev->win_x, ev->win_y);
+  if (!_scint->HaveMouseCapture()) {
+    if (_scint->tryDrag) {
+      _scint->tryDrag = false;
+      _scint->SetEmptySelection(_scint->PositionFromLocation(pt));
+      _scint->SetDragPosition(SelectionPosition(invalidPosition));
+    }
+    return 1;
+  }
+  _scint->ButtonUp(pt, ev->time, (ev->state & CONTROLMASK) != 0);
+  return 1;
+}
+
+long FXScintilla::onRightBtnPress(FXObject *, FXSelector sel, void * ptr)
+{
+//  if (FXScrollArea::onRightBtnPress(sender, sel, ptr))
+//    return 1;
+  if (target && target->handle(this, MKUINT(message, FXSELTYPE(sel)), ptr))
+    return 1;
+  if (!_scint->getDisplayPopupMenu())
+    return 0;
+  FXEvent * ev = static_cast<FXEvent *>(ptr);
+  _scint->ContextMenu(Point(ev->root_x, ev->root_y));
+  return 1;
+}
+
+long FXScintilla::onMiddleBtnPress(FXObject *, FXSelector, void * ptr)
+{
+//  if (FXScrollArea::onMiddleBtnPress(sender, sel, ptr))
+//    return 1;
+  int pos;
+  Point pt;
+  pt.x = ((FXEvent *)ptr)->win_x;
+  pt.y = ((FXEvent *)ptr)->win_y;
+  pos=_scint->PositionFromLocation(pt);
+  _scint->ReceivedSelection(FROM_SELECTION, pos); 
+//  _scint->currentPos = pos; // JKP: Delay asignment of currentPos until AFTER ReceivedSelection()
+//  _scint->anchor = pos; // JKP
+  return 1;
+}
+
+// ********************************************************************
+// Keyboard
+// ********************************************************************
+
+// Map the keypad keys to their equivalent functions
+static int KeyTranslate(int keyIn) {
+  switch (keyIn) {
+    case KEY_ISO_Left_Tab:
+      return SCK_TAB;
+    case KEY_KP_Down:
+      return SCK_DOWN;
+    case KEY_KP_Up:
+      return SCK_UP;
+    case KEY_KP_Left:
+      return SCK_LEFT;
+    case KEY_KP_Right:
+      return SCK_RIGHT;
+    case KEY_KP_Home:
+      return SCK_HOME;
+    case KEY_KP_End:
+      return SCK_END;
+    case KEY_KP_Page_Up:
+      return SCK_PRIOR;
+    case KEY_KP_Page_Down:
+      return SCK_NEXT;
+    case KEY_KP_Delete:
+      return SCK_DELETE;
+    case KEY_KP_Insert:
+      return SCK_INSERT;
+    case KEY_KP_Enter:
+      return SCK_RETURN;
+      
+    case KEY_Down:
+      return SCK_DOWN;
+    case KEY_Up:
+      return SCK_UP;
+    case KEY_Left:
+      return SCK_LEFT;
+    case KEY_Right:
+      return SCK_RIGHT;
+    case KEY_Home:
+      return SCK_HOME;
+    case KEY_End:
+      return SCK_END;
+    case KEY_Page_Up:
+      return SCK_PRIOR;
+    case KEY_Page_Down:
+      return SCK_NEXT;
+    case KEY_Delete:
+      return SCK_DELETE;
+    case KEY_Insert:
+      return SCK_INSERT;
+    case KEY_Escape:
+      return SCK_ESCAPE;
+    case KEY_BackSpace:
+      return SCK_BACK;
+    case KEY_Tab:
+      return SCK_TAB;
+    case KEY_Return:
+      return SCK_RETURN;
+    case KEY_KP_Add:
+      return SCK_ADD;
+    case KEY_KP_Subtract:
+      return SCK_SUBTRACT;
+    case KEY_KP_Divide:
+      return SCK_DIVIDE;
+    default:
+      return keyIn;
+  }
+}
+
+long FXScintilla::onKeyPress(FXObject* sender,FXSelector sel,void* ptr)
+{
+  // Try handling it in base class first
+  if (FXScrollArea::onKeyPress(sender,sel,ptr)) return 1;
+
+  FXEvent *event=(FXEvent*)ptr;
+  bool shift = (event->state & SHIFTMASK) != 0;
+  bool ctrl = (event->state & CONTROLMASK) != 0;
+  bool alt = (event->state & ALTMASK) != 0;
+  FXint len = event->text.length();
+  // Check for multi-byte UTF-8 character
+  if ((_scint->pdoc->dbcsCodePage==SC_CP_UTF8)&&(len>1)&&(len<5) && !(ctrl||alt)) {
+   const int lengthInserted = _scint->pdoc->InsertString(_scint->CurrentPosition(), (const char*)event->text.text(), event->text.length());
+    if (lengthInserted > 0) {
+      _scint->MovePositionTo(_scint->CurrentPosition() + lengthInserted);
+    }
+    return 1;
+  }
+  // <FIXME> Workaround for event->code doesn't hold the correct
+  // KEY_xxx under WIN32
+#ifndef WIN32
+  int key = (event->code) ? event->code : event->text[0];
+#else
+  if (!event->text[0] && (event->code < 256))
+    return 0; // We did not handle it!
+  int key = (((unsigned int)(event->text[0]) >= 32) && !ctrl && !alt) ?
+    event->text[0] : event->code;
+#endif
+  // </FIXME>
+  if (ctrl && (key < 128))
+    key = toupper(key);
+  else if (!ctrl && (key >= KEY_KP_Multiply && key <= KEY_KP_9))
+    key &= 0x7F;
+  // Hack for keys over 256 and below command keys but makes Hungarian work.
+  // This will have to change for Unicode
+  else if ((key >= 0x100) && (key < 0x1000))
+    key &= 0xff;
+  else  
+    key = KeyTranslate(key);
+
+  bool consumed = false;
+  bool added = _scint->KeyDown(key, shift, ctrl, alt, &consumed) != 0;
+  if (!consumed)
+    consumed = added;
+  //Platform::DebugPrintf("SK-key: %d %x %x\n",event->code, event->state, consumed);
+  if (event->code == 0xffffff && event->text.length() > 0) {
+    _scint->ClearSelection();
+    const int lengthInserted = _scint->pdoc->InsertString(_scint->CurrentPosition(), (const char*)event->text.text(), event->text.length());
+    if (lengthInserted > 0) {
+      _scint->MovePositionTo(_scint->CurrentPosition() + lengthInserted);
+    }
+    consumed = true;
+  }
+  return consumed ? 1 : 0;
+}
+
+// ********************************************************************
+// Clipboard
+// ********************************************************************
+
+// We lost the clipboard somehow
+long FXScintilla::onClipboardLost(FXObject* sender,FXSelector sel,void* ptr){
+  FXScrollArea::onClipboardLost(sender,sel,ptr);
+  //Platform::DebugPrintf("Clipboard lost\n");
+  _scint->copyText.Clear();
+
+  return 1;
+}
+
+// Somebody wants our clipboard
+long FXScintilla::onClipboardRequest(FXObject* sender,FXSelector sel,void* ptr){
+  FXEvent *event=(FXEvent*)ptr;
+  FXuchar *cbdata;
+  FXDragType types[]={utf8Type,stringType,0};
+
+  // Try handling it in base class first
+  if(FXScrollArea::onClipboardRequest(sender,sel,ptr)) return 1;
+
+  for (FXDragType *dt=InUTF8Mode(_scint)?types:types+1; *dt; dt++) {
+    if(event->target==*dt){
+      // <FIXME> Framework taken from FXTextField.cpp - Should have a look to FXText.cpp too!
+      size_t len=_scint->copyText.Length();
+	  if (_scint->copyText.rectangular) {len++;}
+      FXCALLOC(&cbdata,FXuchar,len+1);
+      memcpy(cbdata,_scint->copyText.Data(),len);
+  #ifndef WIN32
+      setDNDData(FROM_CLIPBOARD,*dt,cbdata,len);
+  #else
+      setDNDData(FROM_CLIPBOARD,*dt,cbdata,len+1);
+  #endif
+      // </FIXME>
+      return 1;
+    }
+  }
+  return 0;
+}
+
+// ********************************************************************
+// Drag'n drop
+// ********************************************************************
+
+// Start a drag operation
+long FXScintilla::onBeginDrag(FXObject* sender,FXSelector sel,void* ptr){
+  _scint->SetMouseCapture(true);
+  if (FXScrollArea::onBeginDrag(sender,sel,ptr)) return 1;
+  beginDrag(&textType,1);
+  setDragCursor(getApp()->getDefaultCursor(DEF_DNDSTOP_CURSOR));
+  return 1;
+}
+
+
+// End drag operation
+long FXScintilla::onEndDrag(FXObject* sender,FXSelector sel,void* ptr){
+  _scint->inDragDrop = _scint->ddNone; // <-JKP: Fix for mouse not releasing.
+  _scint->SetMouseCapture(false);
+  if (FXScrollArea::onEndDrag(sender,sel,ptr)) return 1;
+  endDrag((didAccept()!=DRAG_REJECT));
+  setDragCursor(getApp()->getDefaultCursor(DEF_TEXT_CURSOR));
+  _scint->SetDragPosition(SelectionPosition(invalidPosition));
+  return 1;
+}
+
+
+// Dragged stuff around
+long FXScintilla::onDragged(FXObject* sender,FXSelector sel,void* ptr) {
+  FXEvent* event=(FXEvent*)ptr;
+  FXDragAction action;
+  if(FXScrollArea::onDragged(sender,sel,ptr)) return 1;
+  action=DRAG_COPY;
+  if (!_scint->pdoc->IsReadOnly()) {
+    if (isDropTarget()) action=DRAG_MOVE;
+    if (event->state&CONTROLMASK) action=DRAG_COPY;
+    if (event->state&SHIFTMASK) action=DRAG_MOVE;
+  }
+  handleDrag(event->root_x,event->root_y,action);
+
+  switch (didAccept()) {
+    case DRAG_MOVE:
+      setDragCursor(getApp()->getDefaultCursor(DEF_DNDMOVE_CURSOR));
+      break;
+    case DRAG_COPY:
+      setDragCursor(getApp()->getDefaultCursor(DEF_DNDCOPY_CURSOR));
+      break;
+    default:
+      setDragCursor(getApp()->getDefaultCursor(DEF_DNDSTOP_CURSOR));
+      break;
+  }
+  return 1;
+}
+
+
+// Handle drag-and-drop enter
+long FXScintilla::onDNDEnter(FXObject* sender,FXSelector sel,void* ptr) {
+  FXScrollArea::onDNDEnter(sender,sel,ptr);
+  return 1;
+}
+
+
+// Handle drag-and-drop leave
+long FXScintilla::onDNDLeave(FXObject* sender,FXSelector sel,void* ptr) {
+  stopAutoScroll();
+  FXScrollArea::onDNDLeave(sender,sel,ptr);
+  return 1;
+}
+
+// Handle drag-and-drop motion
+long FXScintilla::onDNDMotion(FXObject* sender,FXSelector sel,void* ptr){
+  FXEvent* ev=(FXEvent*)ptr;
+  FXDragAction action;
+  FXint pos;
+  // Scroll into view
+  if(startAutoScroll(ev, true)) return 1;
+
+  // Handled elsewhere
+  if(FXScrollArea::onDNDMotion(sender,sel,ptr)) return 1;
+
+  // Correct drop type
+  if (offeredDNDType(FROM_DRAGNDROP,textType) ){
+
+    // Is target editable?
+    if (!_scint->pdoc->IsReadOnly()) {
+      action=inquireDNDAction();
+      // Check for legal DND action
+      if (action==DRAG_COPY || action==DRAG_MOVE) {
+        Point npt(ev->win_x, ev->win_y);
+        pos = _scint->PositionFromLocation(npt);
+        if (!_scint->inDragDrop) {
+          _scint->inDragDrop = _scint->ddDragging; /*** or ddInitial ??? ***/
+          _scint->ptMouseLastBeforeDND = _scint->ptMouseLast;
+        }
+        _scint->ptMouseLast = npt;
+        _scint->SetDragPosition(SelectionPosition(pos));
+
+        // JKP: Changed the logic here...
+        if ( (!_scint->PositionInSelection(pos)) || (_scint->pdoc->Length()==0) ) {
+          acceptDrop(DRAG_ACCEPT);
+          setFocus();
+        }
+      }
+    }
+    return 1;
+  }
+
+  // Didn't handle it here
+  return 0;
+}
+
+
+// Handle drag-and-drop drop
+long FXScintilla::onDNDDrop(FXObject* sender,FXSelector sel,void* ptr){
+  FXuchar *dnddata,*junk;
+  FXuint len,dum;
+
+  // Stop scrolling
+  stopAutoScroll();
+
+  // Try handling it in base class first
+  if(FXScrollArea::onDNDDrop(sender,sel,ptr)) return 1;
+
+  // Should really not have gotten this if non-editable
+  if (!_scint->pdoc->IsReadOnly()) {
+
+    // Try handle here
+    if(getDNDData(FROM_DRAGNDROP,textType,dnddata,len)){
+      _scint->dragWasDropped = true;
+      FXRESIZE(&dnddata,FXchar,len+1); dnddata[len]='\0';
+
+      // Need to ask the source to delete his copy
+      if(inquireDNDAction()==DRAG_MOVE){
+        getDNDData(FROM_DRAGNDROP,deleteType,junk,dum);
+        FXASSERT(!junk);
+      }
+
+      // Insert the new text
+      bool isRectangular = ((len > 0) &&
+          (dnddata[len] == 0 && dnddata[len-1] == '\n'));
+      _scint->DropAt(_scint->posDrop, (const char *)(dnddata), false, isRectangular);
+    
+      FXFREE(&dnddata);
+    }
+    else if (getDNDData(FROM_DRAGNDROP,urilistType,dnddata,len)) {
+      _scint->dragWasDropped = true;
+      FXRESIZE(&dnddata,FXchar,len+1); dnddata[len]='\0';
+      _scint->NotifyURIDropped((FXchar *)dnddata);
+    }
+    return 1;
+  }
+  return 0;
+}
+
+// Service requested DND data
+long FXScintilla::onDNDRequest(FXObject* sender,FXSelector sel,void* ptr) {
+  FXEvent *event=(FXEvent*)ptr;
+
+  // Perhaps the target wants to supply its own data
+  if(FXScrollArea::onDNDRequest(sender,sel,ptr)) return 1;
+
+  // Return dragged text
+  if(event->target==textType){
+    if (_scint->primary.Empty()) {
+      _scint->CopySelectionRange(&_scint->primary);
+
+    }
+        if (!_scint->primary.Empty()) { /* JKP: This will crash if _scint->primary.s is NULL, so we test it first !!! */
+          setDNDData(FROM_DRAGNDROP,stringType,(FXuchar *)strdup(_scint->primary.Data()),_scint->primary.Length());
+        } else { setDNDData(FROM_DRAGNDROP,stringType,NULL,0); }
+    return 1;
+    }
+
+  // Delete dragged text
+  if(event->target==deleteType){
+    if (!_scint->pdoc->IsReadOnly()) {
+      if (isDragging()) {
+        int selStart = _scint->SelectionStart().Position();
+        int selEnd = _scint->SelectionEnd().Position();
+        if (_scint->posDrop.Position() > selStart) {
+          if (_scint->posDrop.Position() > selEnd)
+            _scint->posDrop.SetPosition(_scint->posDrop.Position() - (selEnd-selStart));
+          else
+            _scint->posDrop.SetPosition(selStart);
+          _scint->posDrop.SetPosition(_scint->pdoc->ClampPositionIntoDocument(_scint->posDrop.Position()));
+        }
+      }
+      _scint->ClearSelection();
+      }
+    return 1;
+    }
+
+  return 0;
+}
+
+// ********************************************************************
+// Selection
+// ********************************************************************
+
+// We lost the selection somehow
+long FXScintilla::onSelectionLost(FXObject* sender,FXSelector sel,void* ptr){
+  FXbool hadselection=hasSelection();  
+  FXScrollArea::onSelectionLost(sender,sel,ptr);
+  if (hadselection) {
+    _scint->UnclaimSelection();
+  }
+  return 1;
+}
+
+
+// Somebody wants our selection
+long FXScintilla::onSelectionRequest(FXObject* sender,FXSelector sel,void* ptr){
+  FXEvent *event=(FXEvent*)ptr;
+  FXDragType types[]={utf8Type,stringType,0};
+  // Perhaps the target wants to supply its own data for the selection
+  if (FXScrollArea::onSelectionRequest(sender,sel,ptr)) { return 1; }
+
+  for (FXDragType *dt=InUTF8Mode(_scint)?types:types+1; *dt; dt++) {
+    // Return text of the selection
+    if (event->target==*dt) {
+      if (_scint->primary.Empty()) {
+        _scint->CopySelectionRange(&_scint->primary);
+      }
+      if (!_scint->primary.Empty()) {
+        setDNDData(FROM_SELECTION,*dt,(FXuchar *)strdup(_scint->primary.Data()),strlen(_scint->primary.Data()));
+        return 1;
+      }
+    }
+  }
+  return 0;
+}
+
+// ********************************************************************
+// Scrolling
+// ********************************************************************
+
+FXint FXScintilla::getViewportWidth()
+{
+  return _scint->GetTextRectangle().Width();
+  //return FXScrollArea::getViewportWidth();
+}
+
+FXint FXScintilla::getViewportHeight()
+{
+  //return (_scint) ? _scint->GetTextRectangle().Height() : FXScrollArea::getViewportHeight();
+#ifdef FOX_1_6
+  return FXScrollArea::getViewportHeight();
+#else
+  return FXScrollArea::getVisibleHeight();
+#endif
+}
+
+FXint FXScintilla::getContentWidth()
+{
+  return FXMAX(_scint->scrollWidth, 0);
+}
+
+FXint FXScintilla::getContentHeight()
+{
+  return
+    _scint->cs.LinesDisplayed() * _scint->vs.lineHeight +
+    // This part is a kind of magic, to have the correct scrollbar
+    // behavior regarding the last line of the text
+    (getViewportHeight() + _scint->vs.maxDescent) % _scint->vs.lineHeight;
+}
+
+void FXScintilla::moveContents(FXint x,FXint y)
+{
+  _scint->inMoveContents = true;
+  bool moved = false;
+  int line = (-y + _scint->vs.lineHeight / 2) / _scint->vs.lineHeight;
+
+#ifdef FOX_1_6
+    if (line != getYPosition()/_scint->vs.lineHeight)
+    {
+    moved = true;
+    _scint->ScrollTo(line);
+  }
+    if (x != getXPosition())
+    {
+    moved = true;
+    _scint->HorizontalScrollTo(-x);
+  }
+#else
+  FXint gpx,gpy;
+  getPosition(gpx,gpy);
+  if (line != gpy/_scint->vs.lineHeight) 
+    {
+    moved = true;
+    _scint->ScrollTo(line);
+  }
+  getPosition(gpx,gpy);
+  if (x != gpx) 
+    {
+    moved = true;
+    _scint->HorizontalScrollTo(-x);
+  }
+
+#endif
+
+  if (moved) {
+    FXScrollArea::moveContents(x, -line * _scint->vs.lineHeight);
+  }
+  _scint->inMoveContents = false;
+}
+
+long FXScintilla::onConfigure(FXObject *sender, FXSelector sel, void * ptr)
+{
+  long ret = FXScrollArea::onConfigure(sender, sel, ptr);
+  _scint->ChangeSize();
+  return ret;
+}
+
+// ********************************************************************
+// Messenging
+// ********************************************************************
+
+void FXScintilla::setScintillaID(int sid)
+{
+  _scint->ctrlID = sid;
+}
+
+sptr_t FXScintilla::sendMessage(unsigned int iMessage, uptr_t wParam, sptr_t lParam) {
+  return _scint->WndProc(iMessage, wParam, lParam);
+}
+
+
diff -NaurB scintilla-3.5.2/fox/version.h scintilla-3.5.2-fox/fox/version.h
--- scintilla-3.5.2/fox/version.h	1970-01-01 01:00:00.000000000 +0100
+++ scintilla-3.5.2-fox/fox/version.h	2019-06-15 13:20:16.618260600 +0200
@@ -0,0 +1,4 @@
+FXString FXScintilla::version()
+{
+	return "3.5.2";
+}
diff -NaurB scintilla-3.5.2/include/FXScintilla.h scintilla-3.5.2-fox/include/FXScintilla.h
--- scintilla-3.5.2/include/FXScintilla.h	1970-01-01 01:00:00.000000000 +0100
+++ scintilla-3.5.2-fox/include/FXScintilla.h	2014-12-04 12:30:18.000000000 +0100
@@ -0,0 +1,109 @@
+/** FXScintilla source code edit control
+ *
+ *  FXScintilla.h - Interface for the FOX Scintilla widget
+ *
+ *  Copyright 2001-2004 by Gilles Filippini <gilles.filippini@free.fr>
+ *
+ *  ====================================================================
+ *
+ *  This file is part of FXScintilla.
+ * 
+ *  FXScintilla is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU Lesser General Public License as published by
+ *  the Free Software Foundation; either version 2.1 of the License, or
+ *  (at your option) any later version.
+ *
+ *  FXScintilla is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public License
+ *  along with FXScintilla; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ **/
+
+#ifndef FXScintilla_H
+#define FXScintilla_H
+
+class ScintillaFOX;
+
+#define SCID(id) (FXScrollArea::ID_LAST+id)
+
+class FXAPI FXScintilla : public FXScrollArea
+{
+  friend class ScintillaFOX;
+  FXDECLARE(FXScintilla)
+protected:
+  ScintillaFOX * _scint;
+protected:
+  FXScintilla();
+public:
+  enum {
+    idLast = SCID(100),
+    ID_TICK_CARET,
+    ID_TICK_SCROLL,
+    ID_TICK_WIDEN,
+    ID_TICK_DWELL,
+    ID_TICK_PLATFORM,
+    ID_IDLE,
+    ID_STYLE_IDLE,
+    ID_LAST
+  };
+public:
+  static FXString version();
+  long onScintillaCommand(FXObject *, FXSelector, void*);
+  long onCommand(FXObject *, FXSelector, void*);
+  long onChanged(FXObject *, FXSelector, void*);
+  long onPaint(FXObject *, FXSelector, void *);
+  long onConfigure(FXObject *, FXSelector, void *);
+  long onTimeoutTicking(FXObject *, FXSelector, void *);
+  long onChoreIdle(FXObject *, FXSelector, void *);
+  long onChoreStyleIdle(FXObject *, FXSelector, void *);
+  long onFocusIn(FXObject *, FXSelector, void *);
+  long onFocusOut(FXObject *, FXSelector, void *);
+  long onMotion(FXObject *, FXSelector, void *);
+  long onLeftBtnPress(FXObject *, FXSelector, void *);
+  long onLeftBtnRelease(FXObject *, FXSelector, void *);
+  long onRightBtnPress(FXObject *, FXSelector, void *);
+  long onMiddleBtnPress(FXObject *, FXSelector, void *);
+  long onBeginDrag(FXObject *, FXSelector, void *);
+  long onDragged(FXObject *, FXSelector, void *);
+  long onEndDrag(FXObject *, FXSelector, void *);
+  long onDNDEnter(FXObject *, FXSelector, void *);
+  long onDNDLeave(FXObject *, FXSelector, void *);
+  long onDNDMotion(FXObject *, FXSelector, void *);
+  long onDNDDrop(FXObject *, FXSelector, void *);
+  long onDNDRequest(FXObject *, FXSelector, void *);
+  long onSelectionLost(FXObject *, FXSelector, void *);
+  long onSelectionRequest(FXObject *, FXSelector, void *);
+  long onClipboardLost(FXObject *, FXSelector, void *);
+  long onClipboardRequest(FXObject *, FXSelector, void *);
+  long onKeyPress(FXObject *, FXSelector, void *);
+//  long onSelectionGained(FXObject *, FXSelector, void *); // JKP
+//  long onClipboardGained(FXObject *, FXSelector, void *); // JKP
+public:
+  /// Constructor
+  FXScintilla(FXComposite * p, FXObject * tgt = NULL, FXSelector sel = 0,
+    FXuint opts = 0, FXint x = 0, FXint y = 0, FXint w = 0, FXint h = 0);
+
+  // From FXScrollArea
+  virtual void create();
+  virtual void destroy();
+  virtual bool canFocus() const;
+
+  virtual FXint getViewportWidth();
+  virtual FXint getViewportHeight();
+  virtual FXint getContentWidth();
+  virtual FXint getContentHeight();
+  virtual void moveContents(FXint x,FXint y);
+
+  /// Scintilla messaging
+  void setScintillaID(int sid);
+  sptr_t sendMessage(unsigned int iMessage, uptr_t wParam, sptr_t lParam);
+
+  /// Destructor
+  ~FXScintilla();
+};
+
+#endif // FXScintilla_H
diff -NaurB scintilla-3.5.2/include/Platform.h scintilla-3.5.2-fox/include/Platform.h
--- scintilla-3.5.2/include/Platform.h	2014-05-22 01:24:18.000000000 +0200
+++ scintilla-3.5.2-fox/include/Platform.h	2014-12-04 12:30:18.000000000 +0100
@@ -84,13 +84,40 @@
 // Underlying the implementation of the platform classes are platform specific types.
 // Sometimes these need to be passed around by client code so they are defined here
 
+#if PLAT_FOX
+
+namespace FX {
+
+class FXFont;
+class FXDrawable;
+class FXWindow;
+class FXMenuPane;
+class FXList;
+class FXChore;
+# ifndef WIN32
+class FXTimer;
+# else
+struct FXTimer;
+# endif	// WIN32
+
+};
+using namespace FX;
+
+typedef FXFont * FontID;
+typedef void * SurfaceID;
+typedef FXWindow * WindowID;
+typedef FXMenuPane * MenuID;
+typedef FXTimer * TickerID;
+typedef FXChore * IdlerID;
+#else
 typedef void *FontID;
 typedef void *SurfaceID;
 typedef void *WindowID;
 typedef void *MenuID;
 typedef void *TickerID;
-typedef void *Function;
 typedef void *IdlerID;
+#endif
+typedef void *Function;
 
 /**
  * A geometric point class.
@@ -374,6 +401,9 @@
 	void SetPosition(PRectangle rc);
 	void SetPositionRelative(PRectangle rc, Window relativeTo);
 	PRectangle GetClientPosition();
+#if PLAT_FOX
+	virtual
+#endif
 	void Show(bool show=true);
 	void InvalidateAll();
 	void InvalidateRectangle(PRectangle rc);
